<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Mild_Donkey
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="Mild_Donkey" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head>
    
		<!-- Layouts -->



              <!--  代码渲染  -->
              <link rel="stylesheet" href="/css/prism_coy.css" />
              <link rel="stylesheet" href="/css/typo.css" />
              <!-- 文章页 -->

              <body class>
                <!-- Wrapper 外包 s-->
                <div id="wrapper" class="fade-in">
                  <!-- Intro 头部显示 s -->
                  <!-- Intro 头部显示 e -->
                  <!-- Header 头部logo start -->
                  <header id="header">
    <a href="/" class="logo">Think Different</a>
</header>
                    <!-- Nav 导航条 start -->
                    <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">Home</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">Categories</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/AlgoRhythm/">AlgoRhythm</a></li><li><a class="category-link" href="/categories/Contests/">Contests</a></li><li><a class="category-link" href="/categories/Datastructure/">Datastructure</a></li><li><a class="category-link" href="/categories/Engineering/">Engineering</a></li><li><a class="category-link" href="/categories/Essays/">Essays</a></li><li><a class="category-link" href="/categories/Mathematics/">Mathematics</a></li><li><a class="category-link" href="/categories/Music/">Music</a></li><li><a class="category-link" href="/categories/Notes/">Notes</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        <li class="active">
	            <a href="#s1">Archives</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="archive-link" href="/archives/2024/10/">October 2024</a></li><li><a class="archive-link" href="/archives/2024/06/">June 2024</a></li><li><a class="archive-link" href="/archives/2023/10/">October 2023</a></li><li><a class="archive-link" href="/archives/2023/08/">August 2023</a></li><li><a class="archive-link" href="/archives/2023/05/">May 2023</a></li><li><a class="archive-link" href="/archives/2022/08/">August 2022</a></li><li><a class="archive-link" href="/archives/2022/07/">July 2022</a></li><li><a class="archive-link" href="/archives/2022/06/">June 2022</a></li><li><a class="archive-link" href="/archives/2022/05/">May 2022</a></li><li><a class="archive-link" href="/archives/2022/04/">April 2022</a></li><li><a class="archive-link" href="/archives/2022/03/">March 2022</a></li><li><a class="archive-link" href="/archives/2022/02/">February 2022</a></li><li><a class="archive-link" href="/archives/2022/01/">January 2022</a></li><li><a class="archive-link" href="/archives/2021/11/">November 2021</a></li><li><a class="archive-link" href="/archives/2021/10/">October 2021</a></li><li><a class="archive-link" href="/archives/2021/08/">August 2021</a></li><li><a class="archive-link" href="/archives/2021/05/">May 2021</a></li><li><a class="archive-link" href="/archives/2020/11/">November 2020</a></li><li><a class="archive-link" href="/archives/1978/10/">October 1978</a>
	                    </ul>
	        </li>
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="About">
		                About
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="Friends">
		                Friends
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="Gallery">
		                Gallery
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="Tags">
		                Tags
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/Wild-Donkey" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

                      <div id="main">
                        <div class="post_page_title_img"
                          style="height: 25rem;background-image: url(/images/21thCenturyBreakdown.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                          <a href="#" style="padding: 4rem 4rem 2rem 4rem ;">
                            <h2>
                              学赛博手艺 玩电子puzzle
                            </h2>
                          </a>
                        </div>
                        <!-- Post -->
                        <div class="typo" style="padding: 3rem;">
                          <h1 id="反汇编拆弹"><a class="markdownIt-Anchor" href="#反汇编拆弹"></a> 反汇编拆弹</h1>
<h2 id="学赛博手艺-玩电子puzzle"><a class="markdownIt-Anchor" href="#学赛博手艺-玩电子puzzle"></a> 学赛博手艺 玩电子puzzle</h2>
<h3 id="string_length"><a class="markdownIt-Anchor" href="#string_length"></a> <code>&lt;string_length&gt;</code></h3>
<p>字符串头指针存在栈顶下方 <code>4</code> 字节的位置, 也就是调用 <code>&lt;string_length&gt;</code> 之前的栈顶元素, 字符串长度通过 <code>%eax</code> 返回.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x00001b03 &lt;+0&gt;:     mov    0x4(%esp),%edx</span><br><span class="line">0x00001b07 &lt;+4&gt;:     cmpb   $0x0,(%edx)</span><br><span class="line">0x00001b0a &lt;+7&gt;:     je     0x1b1b &lt;string_length+24&gt;</span><br><span class="line">0x00001b0c &lt;+9&gt;:     mov    $0x0,%eax</span><br></pre></td></tr></table></figure>
<p><code>&lt;string_length+4&gt;</code> 中, 判断了 <code>%edx</code> 指向的内存地址中的值是否为 <code>0</code>, <code>b</code> 表示判断是否为 <code>0</code> 的数据大小是一个字节. 如果为 <code>0</code>, 则标志寄存器的 <code>ZF</code> 位被赋为 <code>1</code>, 否则赋为 <code>0</code>. 随后的 <code>je</code> 语句就会在 <code>ZF</code> 为 <code>1</code> 时将程序跳转到 <code>&lt;string_length+24&gt;</code>, 否则不跳.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x00001b11 &lt;+14&gt;:    add    $0x1,%eax</span><br><span class="line">0x00001b14 &lt;+17&gt;:    cmpb   $0x0,(%edx,%eax,1)</span><br><span class="line">0x00001b18 &lt;+21&gt;:    jne    0x1b11 &lt;string_length+14&gt;</span><br><span class="line">0x00001b1a &lt;+23&gt;:    ret</span><br></pre></td></tr></table></figure>
<p>从 <code>&lt;string_length+14&gt;</code> 到 <code>&lt;string_length+21&gt;</code> 是一个循环. 表示判断内存中 <code>%edx + %eax</code> 地址的值是否为 <code>0</code>. <code>jne</code> 和 <code>je</code> 的区别是跳转的条件不同, 这里的 <code>jne</code> 语句是指 <code>ZF</code> 位为 <code>0</code> 时跳转到 <code>&lt;string_length+14&gt;</code>. 循环在做的事情是从传入 <code>%edx</code> 的地址开始, 每次判断一个位置是否为 <code>0</code>, 如果没有遇到 <code>0</code> 就继续探查, 将已经判断过的位置数量存入 <code>%eax</code>, 当遇到 <code>0</code> 就返回, 这时 <code>%eax</code> 内的值就是字符串长度.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00001b1b &lt;+24&gt;:    mov    $0x0,%eax</span><br><span class="line">0x00001b20 &lt;+29&gt;:    ret</span><br></pre></td></tr></table></figure>
<p>这一段只能由 <code>&lt;string_length+7&gt;</code> 跳转而来, 表示字符串的首位就是 <code>0</code>, 即长度为 <code>0</code>, 将这个长度存入 <code>%eax</code> 后返回.</p>
<hr />
<h3 id="strings_not_equal"><a class="markdownIt-Anchor" href="#strings_not_equal"></a> <code>&lt;strings_not_equal&gt;</code></h3>
<p>判断两个字符串是否相等, 相等会赋 <code>%eax</code> 为 <code>0</code>, 否则为 <code>1</code>. 判断的两个字符串头指针需在调用前存入栈顶和栈顶下方一个元素.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x00001b21 &lt;+0&gt;:     push   %edi</span><br><span class="line">0x00001b22 &lt;+1&gt;:     push   %esi</span><br><span class="line">0x00001b23 &lt;+2&gt;:     push   %ebx</span><br><span class="line">0x00001b24 &lt;+3&gt;:     mov    0x10(%esp),%ebx</span><br><span class="line">0x00001b28 &lt;+7&gt;:     mov    0x14(%esp),%esi</span><br></pre></td></tr></table></figure>
<p>从调用 <code>&lt;strings_not_equal&gt;</code> 开始, 栈顶一共移动了 <code>0x10</code> 个字节, 所以 <code>%ebx</code> 会被赋值为调用 <code>&lt;strings_not_equal&gt;</code> 前的栈顶, 而 <code>%esi</code> 会被赋值为这个栈顶下方一个元素的值. 这时开始, <code>%ebx</code>, <code>%esi</code> 分别存储两个字符串的头指针.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x00001b2c &lt;+11&gt;:    push   %ebx</span><br><span class="line">0x00001b2d &lt;+12&gt;:    call   0x1b03 &lt;string_length&gt;</span><br><span class="line">0x00001b32 &lt;+17&gt;:    mov    %eax,%edi</span><br><span class="line">0x00001b34 &lt;+19&gt;:    mov    %esi,(%esp)</span><br><span class="line">0x00001b37 &lt;+22&gt;:    call   0x1b03 &lt;string_length&gt;</span><br><span class="line">0x00001b3c &lt;+27&gt;:    add    $0x4,%esp</span><br><span class="line">0x00001b3f &lt;+30&gt;:    mov    %eax,%edx</span><br></pre></td></tr></table></figure>
<p><code>&lt;strings_not_equal+12&gt;</code> 求出以 <code>%ebx</code> 内的地址为头指针的字符串的长度, 存入 <code>%edi</code>.<br />
<code>&lt;strings_not_equal+22&gt;</code> 求出以 <code>%esi</code> 内的地址为头指针的字符串的长度, 存入 <code>%edx</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00001b41 &lt;+32&gt;:    mov    $0x1,%eax</span><br><span class="line">0x00001b46 &lt;+37&gt;:    cmp    %edx,%edi</span><br><span class="line">0x00001b48 &lt;+39&gt;:    jne    0x1b75 &lt;strings_not_equal+84&gt;</span><br></pre></td></tr></table></figure>
<p>如果两个字符串的长度不相等, 则将 <code>%eax</code> 赋 <code>1</code>, 退出函数. (<code>return 1</code>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00001b4a &lt;+41&gt;:    movzbl (%ebx),%eax</span><br><span class="line">0x00001b4d &lt;+44&gt;:    test   %al,%al</span><br><span class="line">0x00001b4f &lt;+46&gt;:    je     0x1b69 &lt;strings_not_equal+72&gt;</span><br></pre></td></tr></table></figure>
<p><code>movzbl</code> 中 <code>z</code> 表示 Zero, 表示源长度不足时, 高位用 <code>0</code> 填充. <code>b</code> 表示源大小为字节, <code>l</code> 表示目标大小为长字. 之后判断 <code>%eax</code> 的低 <code>8</code> 位是否为 <code>0</code>, 如果是, 那么跳转到 <code>&lt;strings_not_equal+72&gt;</code>. 也就是将 <code>%eax</code> 赋 <code>0</code>, 退出函数. (<code>return 0</code>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x00001b51 &lt;+48&gt;:    cmp    %al,(%esi)</span><br><span class="line">0x00001b53 &lt;+50&gt;:    jne    0x1b70 &lt;strings_not_equal+79&gt;</span><br><span class="line">0x00001b55 &lt;+52&gt;:    add    $0x1,%ebx</span><br><span class="line">0x00001b58 &lt;+55&gt;:    add    $0x1,%esi</span><br><span class="line">0x00001b5b &lt;+58&gt;:    movzbl (%ebx),%eax</span><br><span class="line">0x00001b5e &lt;+61&gt;:    test   %al,%al</span><br><span class="line">0x00001b60 &lt;+63&gt;:    jne    0x1b51 &lt;strings_not_equal+48&gt;</span><br></pre></td></tr></table></figure>
<p>这一段是一块循环, 循环体可以理解为:</p>
<p><code>if(*a != *b) return 1;</code>, <code>++a, ++b;</code>, <code>if(!(*a)) break;</code>.</p>
<p>逐字节判断两字符串是否相等.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x00001b62 &lt;+65&gt;:    mov    $0x0,%eax</span><br><span class="line">0x00001b67 &lt;+70&gt;:    jmp    0x1b75 &lt;strings_not_equal+84&gt;</span><br><span class="line">0x00001b69 &lt;+72&gt;:    mov    $0x0,%eax</span><br><span class="line">0x00001b6e &lt;+77&gt;:    jmp    0x1b75 &lt;strings_not_equal+84&gt;</span><br><span class="line">0x00001b70 &lt;+79&gt;:    mov    $0x1,%eax</span><br><span class="line">0x00001b75 &lt;+84&gt;:    pop    %ebx</span><br><span class="line">0x00001b76 &lt;+85&gt;:    pop    %esi</span><br><span class="line">0x00001b77 &lt;+86&gt;:    pop    %edi</span><br><span class="line">0x00001b78 &lt;+87&gt;:    ret</span><br></pre></td></tr></table></figure>
<p>这一段从 <code>&lt;strings_not_equal+65&gt;</code> 或 <code>&lt;strings_not_equal+72&gt;</code> 开始执行都表示 <code>return 0;</code>, 从 <code>&lt;strings_not_equal+79&gt;</code> 开始执行表示 <code>return 1;</code>.</p>
<hr />
<h3 id="phase_1"><a class="markdownIt-Anchor" href="#phase_1"></a> <code>&lt;phase_1&gt;</code></h3>
<p>通过设置断点 <code>break 74</code> 在进入 <code>&lt;phase_1&gt;</code> 前暂停执行. 发现调用 <code>&lt;phase_1&gt;</code> 之前, 将栈顶元素赋值为 <code>%eax</code>, 然后查看当前 <code>%eax</code> 的值, 为 <code>0x5655b3a0</code>. 这便是我们输入的字符串的头指针.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x000014cd &lt;+0&gt;:     push   %ebx</span><br><span class="line">0x000014ce &lt;+1&gt;:     sub    $0x10,%esp</span><br></pre></td></tr></table></figure>
<p>前两条指令先入栈, 然后通过对 <code>%esp</code> 的减少, 实现了类似入栈 <code>0x10</code> 个字节的效果. 我们猜测这是在函数内定义了一些局部变量.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x000014d1 &lt;+4&gt;:     call   0x1240 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">0x000014d6 &lt;+9&gt;:     add    $0x4a8e,%ebx</span><br><span class="line">0x000014dc &lt;+15&gt;:    lea    -0x2e20(%ebx),%eax</span><br></pre></td></tr></table></figure>
<p><code>&lt;phase_1+4&gt;</code> 中调用函数 <code>&lt;__x86.get_pc_thunk.bx&gt;</code> 将 <code>PC</code> 的值存入 <code>%ebx</code>. 这时 <code>%ebx</code> 会存储当前指令下一条指令的地址, 假设是 <code>0x000014d6</code>.</p>
<p>后面两句是将 <code>%ebx</code> 的值加上 <code>0x4a8e</code>, 然后减去 <code>0x2e20</code>, 将结果 <code>0x3144</code> 存入 <code>%eax</code> 中. 值得一提的是 lea 虽然用 <code>%ebx</code> 寻址, 但是不会访问这个地址的内存.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x000014e2 &lt;+21&gt;:    push   %eax</span><br><span class="line">0x000014e3 &lt;+22&gt;:    push   0x1c(%esp)</span><br></pre></td></tr></table></figure>
<p>对于 <code>&lt;phase_1+22&gt;</code>, 会先对 <code>0x1c(%esp)</code> 进行寻址, 然后执行 <code>push</code>, 所以这里寻址时的 <code>%esp</code> 还是本条 <code>push</code> 前的 <code>%esp</code>.</p>
<ul>
<li><code>(%esp)</code> 存储的是 <code>&lt;phase_1+21&gt;</code> 压入的值.</li>
<li>从 <code>0x04(%esp)</code> 开始的 <code>0x10</code> 位, 是被 <code>&lt;phase_1+1&gt;</code> 跳过的位.</li>
<li><code>0x14(%esp)</code> 存储 <code>&lt;phase_1+0&gt;</code> 被压入的值.</li>
<li><code>0x18(%esp)</code> 存储调用 <code>&lt;phase_1&gt;</code> 之前的 <code>PC</code>.</li>
</ul>
<p>所以 <code>&lt;phase_1+22&gt;</code> 压入的值是调用 <code>&lt;phase_1&gt;</code> 前的栈顶元素.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x000014e7 &lt;+26&gt;:    call   0x1b21 &lt;strings_not_equal&gt;</span><br><span class="line">0x000014ec &lt;+31&gt;:    add    $0x10,%esp</span><br><span class="line">0x000014ef &lt;+34&gt;:    test   %eax,%eax</span><br><span class="line">0x000014f1 &lt;+36&gt;:    jne    0x14f8 &lt;phase_1+43&gt;</span><br></pre></td></tr></table></figure>
<p>这里判断 <code>&lt;phase_1+21&gt;</code> 和 <code>&lt;phase_1+22&gt;</code> 中压入的头指针对应的两个字符串是否相等. 也就是以 <code>0x3144</code> 为头指针的字符串. 和外层函数传入了头指针的字符串, 即输入的字符串.</p>
<p>如果不相等, 则跳转到 <code>&lt;phase_1+43&gt;</code>, 即引爆炸弹.</p>
<p><code>&lt;phase_1+31&gt;</code> 将 <code>%esp</code> 的值改为了执行 <code>&lt;phase_1+1&gt;</code> 之前, 栈顶上方 <code>8</code> 字节的地址.</p>
<p>在 <code>&lt;strings_not_equal&gt;</code> 中查看从栈中拉出来的 <code>%ebx</code>, <code>%esi</code> 的值 <code>0x5655b3a0</code>, <code>0x56558144</code>, 发现前者恰好是前面解析出的, 输入的字符串的头指针, 后者则是答案串所在的位置. 发现传入的地址和我们之前计算出的 <code>0x3144</code> 不同, 反汇编时显示的地址是以程序开头为基址的相对地址, 而运行时程序被加载在内存中, 所以地址也是在内存中的地址, 因此这里就以运行时的地址为准.</p>
<p>直接找到 <code>0x56558144</code> 处的内存, 其内容为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x /40xb 0x56558144</span><br><span class="line">0x56558144:     0x54    0x68    0x65    0x20    0x66    0x75    0x74    0x75</span><br><span class="line">0x5655814c:     0x72    0x65    0x20    0x77    0x69    0x6c    0x6c    0x20</span><br><span class="line">0x56558154:     0x62    0x65    0x20    0x62    0x65    0x74    0x74    0x65</span><br><span class="line">0x5655815c:     0x72    0x20    0x74    0x6f    0x6d    0x6f    0x72    0x72</span><br><span class="line">0x56558164:     0x6f    0x77    0x2e    0x00    0x57    0x6f    0x77    0x21</span><br></pre></td></tr></table></figure>
<p>发现有效字符串为 <code>36</code> 字节, 翻译成 ASCII 码为: <code>The future will be better tomorrow.</code>. 这便是阶段一的答案.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x000014f3 &lt;+38&gt;:    add    $0x8,%esp</span><br><span class="line">0x000014f6 &lt;+41&gt;:    pop    %ebx</span><br><span class="line">0x000014f7 &lt;+42&gt;:    ret</span><br></pre></td></tr></table></figure>
<p>这里相当于 <code>return;</code>. 通过对 <code>%esp</code> 直接修改, 使得栈顶重新指向 <code>&lt;phase_1+0&gt;</code> 压入的元素. 之后弹栈返回, 将栈顶恢复到调用 <code>&lt;phase_1&gt;</code> 前的位置.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x000014f8 &lt;+43&gt;:    call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x000014fd &lt;+48&gt;:    jmp    0x14f3 &lt;phase_1+38&gt;</span><br></pre></td></tr></table></figure>
<p>引爆后返回.</p>
<hr />
<h3 id="read_six_numbers"><a class="markdownIt-Anchor" href="#read_six_numbers"></a> <code>&lt;read_six_numbers&gt;</code></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0x00001c6e &lt;+0&gt;:     push   %ebx</span><br><span class="line">0x00001c6f &lt;+1&gt;:     sub    $0x8,%esp</span><br><span class="line">0x00001c72 &lt;+4&gt;:     call   0x1240 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">0x00001c77 &lt;+9&gt;:     add    $0x42ed,%ebx</span><br><span class="line">0x00001c7d &lt;+15&gt;:    mov    0x14(%esp),%eax</span><br><span class="line">0x00001c81 &lt;+19&gt;:    lea    0x14(%eax),%edx</span><br><span class="line">0x00001c84 &lt;+22&gt;:    push   %edx</span><br><span class="line">0x00001c85 &lt;+23&gt;:    lea    0x10(%eax),%edx</span><br><span class="line">0x00001c88 &lt;+26&gt;:    push   %edx</span><br><span class="line">0x00001c89 &lt;+27&gt;:    lea    0xc(%eax),%edx</span><br><span class="line">0x00001c8c &lt;+30&gt;:    push   %edx</span><br><span class="line">0x00001c8d &lt;+31&gt;:    lea    0x8(%eax),%edx</span><br><span class="line">0x00001c90 &lt;+34&gt;:    push   %edx</span><br><span class="line">0x00001c91 &lt;+35&gt;:    lea    0x4(%eax),%edx</span><br><span class="line">0x00001c94 &lt;+38&gt;:    push   %edx</span><br><span class="line">0x00001c95 &lt;+39&gt;:    push   %eax</span><br></pre></td></tr></table></figure>
<p>从调用函数前栈顶下方一个长字位置存储的地址开始, 将连续的六个长字地址从下到上压入栈中. 我们可以认为这是给后面的 <code>scanf</code> 传参, 即读取的元素存入的地址.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x00001c96 &lt;+40&gt;:    lea    -0x2c91(%ebx),%eax</span><br><span class="line">0x00001c9c &lt;+46&gt;:    push   %eax</span><br><span class="line">0x00001c9d &lt;+47&gt;:    push   0x2c(%esp)</span><br><span class="line">0x00001ca1 &lt;+51&gt;:    call   0x1140 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">0x00001ca6 &lt;+56&gt;:    add    $0x20,%esp</span><br><span class="line">0x00001ca9 &lt;+59&gt;:    cmp    $0x5,%eax</span><br><span class="line">0x00001cac &lt;+62&gt;:    jle    0x1cb3 &lt;read_six_numbers+69&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;read_six_numbers+56&gt;</code> 一个加法, 将栈顶位置还原成 <code>&lt;read_six_numbers+0&gt;</code> 入栈后的状态.</p>
<p><code>&lt;read_six_numbers+51&gt;</code> 调用了 <code>scanf</code>, 读入数字的数量存入 <code>%eax</code>, 所以在 <code>&lt;read_six_numbers+59&gt;</code>, 判断读入数字数量, 如果小于等于 <code>5</code>, 就引爆炸弹.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x00001cae &lt;+64&gt;:    add    $0x8,%esp</span><br><span class="line">0x00001cb1 &lt;+67&gt;:    pop    %ebx</span><br><span class="line">0x00001cb2 &lt;+68&gt;:    ret</span><br><span class="line">0x00001cb3 &lt;+69&gt;:    call   0x1c39 &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="phase_2"><a class="markdownIt-Anchor" href="#phase_2"></a> <code>&lt;phase_2&gt;</code></h3>
<p>到这里, 汇编的语法已经多次应用了, 会减少对语义的记录, 而是关注功能.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x000014ff &lt;+0&gt;:     push   %edi</span><br><span class="line">0x00001500 &lt;+1&gt;:     push   %esi</span><br><span class="line">0x00001501 &lt;+2&gt;:     push   %ebx</span><br><span class="line">0x00001502 &lt;+3&gt;:     sub    $0x28,%esp</span><br><span class="line">0x00001505 &lt;+6&gt;:     call   0x1240 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">0x0000150a &lt;+11&gt;:    add    $0x4a5a,%ebx</span><br><span class="line">0x00001510 &lt;+17&gt;:    mov    %gs:0x14,%eax</span><br><span class="line">0x00001516 &lt;+23&gt;:    mov    %eax,0x24(%esp)</span><br><span class="line">0x0000151a &lt;+27&gt;:    xor    %eax,%eax</span><br><span class="line">0x0000151c &lt;+29&gt;:    lea    0xc(%esp),%eax</span><br></pre></td></tr></table></figure>
<p>前面仍然是进入函数的一些开空间存变量的操作, <code>0x00001510 &lt;+17&gt;</code> 的 <code>%gs:0x14</code> 表示调用 <code>%gs</code> 段的相对地址为 <code>0x14</code> 的长字存入 <code>%eax</code>.</p>
<p><code>0x00001505 &lt;+6&gt;</code> 到 <code>0x0000151c &lt;+29&gt;</code> 的伪代码: <code>%ebx = PC + 0x4a5a</code>, <code>%eax = *(%gs + 0x14)</code>, <code>*(%esp + 0x24) = %eax</code>, <code>%eax = %esp + 0xc</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x00001520 &lt;+33&gt;:    push   %eax</span><br><span class="line">0x00001521 &lt;+34&gt;:    push   0x3c(%esp)</span><br><span class="line">0x00001525 &lt;+38&gt;:    call   0x1c6e &lt;read_six_numbers&gt;</span><br><span class="line">0x0000152a &lt;+43&gt;:    add    $0x10,%esp</span><br></pre></td></tr></table></figure>
<p>前面对 <code>&lt;read_six_numbers&gt;</code> 解析之后, 发现读入的数字会存储在 <code>%eax</code> 存储的地址开始, 向后共六个长字中. 而调用 <code>&lt;read_six_numbers&gt;</code> 前, <code>%eax</code> 存储的地址是 <code>0xc(%esp)</code>, 也就是执行 <code>&lt;phase_2+43&gt;</code> 之后的 <code>0x4(%esp)</code>. 所以六个数字的地址就是 <code>0x4(%esp)</code>, <code>0x8(%esp)</code>, …, <code>0x18(%esp)</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0000152d &lt;+46&gt;:    cmpl   $0x1,0x4(%esp)</span><br><span class="line">0x00001532 &lt;+51&gt;:    jne    0x153e &lt;phase_2+63&gt;</span><br></pre></td></tr></table></figure>
<p>由此可知密码的第一位是 <code>1</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x00001534 &lt;+53&gt;:    lea    0x4(%esp),%esi</span><br><span class="line">0x00001538 &lt;+57&gt;:    lea    0x18(%esp),%edi</span><br><span class="line">0x0000153c &lt;+61&gt;:    jmp    0x154c &lt;phase_2+77&gt;</span><br><span class="line">0x0000153e &lt;+63&gt;:    call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x00001543 &lt;+68&gt;:    jmp    0x1534 &lt;phase_2+53&gt;</span><br></pre></td></tr></table></figure>
<p>初始化一个循环 <code>%esi</code> 是初地址, <code>%edi</code> 是末地址.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x00001545 &lt;+70&gt;:    add    $0x4,%esi</span><br><span class="line">0x00001548 &lt;+73&gt;:    cmp    %edi,%esi</span><br><span class="line">0x0000154a &lt;+75&gt;:    je     0x155c &lt;phase_2+93&gt;</span><br><span class="line">0x0000154c &lt;+77&gt;:    mov    (%esi),%eax</span><br><span class="line">0x0000154e &lt;+79&gt;:    add    %eax,%eax</span><br><span class="line">0x00001550 &lt;+81&gt;:    cmp    %eax,0x4(%esi)</span><br><span class="line">0x00001553 &lt;+84&gt;:    je     0x1545 &lt;phase_2+70&gt;</span><br><span class="line">0x00001555 &lt;+86&gt;:    call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x0000155a &lt;+91&gt;:    jmp    0x1545 &lt;phase_2+70&gt;</span><br></pre></td></tr></table></figure>
<p>循环体可以理解为这样.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(%edi == (%esi += <span class="number">4</span>)) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">if</span>(*(%esi + <span class="number">4</span>) != (%eax = (*%esi &lt;&lt; <span class="number">1</span>))) explode_bomb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次判断一个新的数, 是否等于上一个数的两倍, 如果不是就引爆炸弹. 由此可以知道, 密码是一个公比为 <code>2</code>, 首项为 <code>1</code> 的等比数列. <code>1 2 4 8 16 32</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x0000155c &lt;+93&gt;:    mov    0x1c(%esp),%eax</span><br><span class="line">0x00001560 &lt;+97&gt;:    sub    %gs:0x14,%eax</span><br><span class="line">0x00001567 &lt;+104&gt;:   jne    0x1570 &lt;phase_2+113&gt;</span><br><span class="line">0x00001569 &lt;+106&gt;:   add    $0x20,%esp</span><br><span class="line">0x0000156c &lt;+109&gt;:   pop    %ebx</span><br><span class="line">0x0000156d &lt;+110&gt;:   pop    %esi</span><br><span class="line">0x0000156e &lt;+111&gt;:   pop    %edi</span><br><span class="line">0x0000156f &lt;+112&gt;:   ret</span><br><span class="line">0x00001570 &lt;+113&gt;:   call   0x2a40 &lt;__stack_chk_fail_local&gt;</span><br></pre></td></tr></table></figure>
<p>后面就是一些返回前的后处理.</p>
<hr />
<h3 id="phase_3"><a class="markdownIt-Anchor" href="#phase_3"></a> <code>&lt;phase_3&gt;</code></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0x00001575 &lt;+0&gt;:     push   %ebx</span><br><span class="line">0x00001576 &lt;+1&gt;:     sub    $0x24,%esp</span><br><span class="line">0x00001579 &lt;+4&gt;:     call   0x1240 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">0x0000157e &lt;+9&gt;:     add    $0x49e6,%ebx</span><br><span class="line">0x00001584 &lt;+15&gt;:    mov    %gs:0x14,%eax</span><br><span class="line">0x0000158a &lt;+21&gt;:    mov    %eax,0x18(%esp)</span><br><span class="line">0x0000158e &lt;+25&gt;:    xor    %eax,%eax</span><br><span class="line">0x00001590 &lt;+27&gt;:    lea    0x14(%esp),%eax</span><br><span class="line">0x00001594 &lt;+31&gt;:    push   %eax</span><br><span class="line">0x00001595 &lt;+32&gt;:    lea    0x13(%esp),%eax</span><br><span class="line">0x00001599 &lt;+36&gt;:    push   %eax</span><br><span class="line">0x0000159a &lt;+37&gt;:    lea    0x18(%esp),%eax</span><br><span class="line">0x0000159e &lt;+41&gt;:    push   %eax</span><br><span class="line">0x0000159f &lt;+42&gt;:    lea    -0x2dd6(%ebx),%eax</span><br><span class="line">0x000015a5 &lt;+48&gt;:    push   %eax</span><br><span class="line">0x000015a6 &lt;+49&gt;:    push   0x3c(%esp)</span><br><span class="line">0x000015aa &lt;+53&gt;:    call   0x1140 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">0x000015af &lt;+58&gt;:    add    $0x20,%esp</span><br><span class="line">0x000015b2 &lt;+61&gt;:    cmp    $0x2,%eax</span><br><span class="line">0x000015b5 &lt;+64&gt;:    jle    0x15d1 &lt;phase_3+92&gt;</span><br></pre></td></tr></table></figure>
<p>根据 <code>&lt;read_six_numbers&gt;</code> 的解析, 从 <code>scanf</code> 的第三个参数 (倒数第三个被压入栈中的元素) 开始, 就是读入的内容存储的位置. 根据 <code>&lt;phase_3+61&gt;</code>, 这里读入了三个元素, 存入了 <code>0x18(%esp)</code>, <code>0x13(%esp)</code>, <code>0x14(%esp)</code>. 不过那是压入栈中的时候的 <code>%esp</code>, 如果改写为 <code>&lt;phase_3+58&gt;</code> 执行后的 <code>%esp</code> 相对位置, 即为 <code>0x4(%esp)</code>, <code>0x3(%esp)</code>, <code>0x8(%esp)</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x000015b7 &lt;+66&gt;:    cmpl   $0x7,0x4(%esp)</span><br><span class="line">0x000015bc &lt;+71&gt;:    ja     0x16bf &lt;phase_3+330&gt;</span><br></pre></td></tr></table></figure>
<p>如果记第一个输入的是整数 <code>A</code>, 第二个输入的是字符 <code>B</code>, 第三个输入的是整数 <code>C</code>, 那么这里当 <code>7 &lt; A</code>, 就引爆炸弹.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x000015c2 &lt;+77&gt;:    mov    0x4(%esp),%eax</span><br><span class="line">0x000015c6 &lt;+81&gt;:    mov    %ebx,%edx</span><br><span class="line">0x000015c8 &lt;+83&gt;:    add    -0x2dc4(%ebx,%eax,4),%edx</span><br><span class="line">0x000015cf &lt;+90&gt;:    jmp    *%edx</span><br></pre></td></tr></table></figure>
<p>这个地方 <code>%ebx</code> 存储的值非常重要, 直接决定了接下来执行的语句, 综合前面的指令, <code>%ebx</code> 的值是 <code>&lt;phase_3+9&gt; + 0x49e6</code>, 跳转到的语句地址即为: <code>(&lt;phase_3+9&gt; + 0x49e6) + *((&lt;phase_3+9&gt; + 0x49e6) + 4A - 0x2dc4)</code>. 也就是说 <code>A</code> 每增加 <code>1</code>, 跳转到的地址便增加 <code>4</code>. 所以决定先将 <code>A</code> 设为 <code>7</code>, 然后建立起跳转到的位置和 <code>A</code> 之间的关系映射.</p>
<p>当 <code>A</code> 为 <code>7</code> 时, 跳转到的地址为 <code>&lt;phase_3+303&gt;</code>, 因此, 跳转的地址即为 <code>&lt;phase_3+(275+4A)&gt;</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">0x000015d1 &lt;+92&gt;:    call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x000015d6 &lt;+97&gt;:    jmp    0x15b7 &lt;phase_3+66&gt;</span><br><span class="line">0x000015d8 &lt;+99&gt;:    mov    $0x75,%eax</span><br><span class="line">0x000015dd &lt;+104&gt;:   cmpl   $0x263,0x8(%esp)</span><br><span class="line">0x000015e5 &lt;+112&gt;:   je     0x16c9 &lt;phase_3+340&gt;</span><br><span class="line">0x000015eb &lt;+118&gt;:   call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x000015f0 &lt;+123&gt;:   mov    $0x75,%eax</span><br><span class="line">0x000015f5 &lt;+128&gt;:   jmp    0x16c9 &lt;phase_3+340&gt;</span><br><span class="line">0x000015fa &lt;+133&gt;:   mov    $0x76,%eax</span><br><span class="line">0x000015ff &lt;+138&gt;:   cmpl   $0x5a,0x8(%esp)</span><br><span class="line">0x00001604 &lt;+143&gt;:   je     0x16c9 &lt;phase_3+340&gt;</span><br><span class="line">0x0000160a &lt;+149&gt;:   call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x0000160f &lt;+154&gt;:   mov    $0x76,%eax</span><br><span class="line">0x00001614 &lt;+159&gt;:   jmp    0x16c9 &lt;phase_3+340&gt;</span><br><span class="line">0x00001619 &lt;+164&gt;:   mov    $0x66,%eax</span><br><span class="line">0x0000161e &lt;+169&gt;:   cmpl   $0x24c,0x8(%esp)</span><br><span class="line">0x00001626 &lt;+177&gt;:   je     0x16c9 &lt;phase_3+340&gt;</span><br><span class="line">0x0000162c &lt;+183&gt;:   call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x00001631 &lt;+188&gt;:   mov    $0x66,%eax</span><br><span class="line">0x00001636 &lt;+193&gt;:   jmp    0x16c9 &lt;phase_3+340&gt;</span><br><span class="line">0x0000163b &lt;+198&gt;:   mov    $0x66,%eax</span><br><span class="line">0x00001640 &lt;+203&gt;:   cmpl   $0xbd,0x8(%esp)</span><br><span class="line">0x00001648 &lt;+211&gt;:   je     0x16c9 &lt;phase_3+340&gt;</span><br><span class="line">0x0000164a &lt;+213&gt;:   call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x0000164f &lt;+218&gt;:   mov    $0x66,%eax</span><br><span class="line">0x00001654 &lt;+223&gt;:   jmp    0x16c9 &lt;phase_3+340&gt;</span><br><span class="line">0x00001656 &lt;+225&gt;:   mov    $0x71,%eax</span><br><span class="line">0x0000165b &lt;+230&gt;:   cmpl   $0x203,0x8(%esp)</span><br><span class="line">0x00001663 &lt;+238&gt;:   je     0x16c9 &lt;phase_3+340&gt;</span><br><span class="line">0x00001665 &lt;+240&gt;:   call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x0000166a &lt;+245&gt;:   mov    $0x71,%eax</span><br><span class="line">0x0000166f &lt;+250&gt;:   jmp    0x16c9 &lt;phase_3+340&gt;</span><br><span class="line">0x00001671 &lt;+252&gt;:   mov    $0x64,%eax</span><br><span class="line">0x00001676 &lt;+257&gt;:   cmpl   $0x6b,0x8(%esp)</span><br><span class="line">0x0000167b &lt;+262&gt;:   je     0x16c9 &lt;phase_3+340&gt;</span><br><span class="line">0x0000167d &lt;+264&gt;:   call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x00001682 &lt;+269&gt;:   mov    $0x64,%eax</span><br><span class="line">0x00001687 &lt;+274&gt;:   jmp    0x16c9 &lt;phase_3+340&gt;</span><br><span class="line">0x00001689 &lt;+276&gt;:   mov    $0x78,%eax</span><br><span class="line">0x0000168e &lt;+281&gt;:   cmpl   $0x224,0x8(%esp)</span><br><span class="line">0x00001696 &lt;+289&gt;:   je     0x16c9 &lt;phase_3+340&gt;</span><br></pre></td></tr></table></figure>
<p>发现从后面的指令, 不存在跳转到这之前的指令的情况, 所以我们可以认为, 上面这一段是没有用的, 无需分析.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00001698 &lt;+291&gt;:   call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x0000169d &lt;+296&gt;:   mov    $0x78,%eax</span><br><span class="line">0x000016a2 &lt;+301&gt;:   jmp    0x16c9 &lt;phase_3+340&gt;</span><br></pre></td></tr></table></figure>
<p>第一个合法的 <code>A</code> 是 <code>A = 4</code>, 但是会直接引爆炸弹.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x000016a4 &lt;+303&gt;:   mov    $0x68,%eax</span><br><span class="line">0x000016a9 &lt;+308&gt;:   cmpl   $0x222,0x8(%esp)</span><br><span class="line">0x000016b1 &lt;+316&gt;:   je     0x16c9 &lt;phase_3+340&gt;</span><br><span class="line">0x000016b3 &lt;+318&gt;:   call   0x1c39 &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>另一个合法的是 <code>A = 7</code> 时, 要求 <code>C = 0x222 = 546</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x000016b8 &lt;+323&gt;:   mov    $0x68,%eax</span><br><span class="line">0x000016bd &lt;+328&gt;:   jmp    0x16c9 &lt;phase_3+340&gt;</span><br><span class="line">0x000016bf &lt;+330&gt;:   call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x000016c4 &lt;+335&gt;:   mov    $0x74,%eax</span><br></pre></td></tr></table></figure>
<p>这一段理论上不会被执行, 不分析.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x000016c9 &lt;+340&gt;:   cmp    %al,0x3(%esp)</span><br><span class="line">0x000016cd &lt;+344&gt;:   jne    0x16e1 &lt;phase_3+364&gt;</span><br><span class="line">0x000016cf &lt;+346&gt;:   mov    0xc(%esp),%eax</span><br><span class="line">0x000016d3 &lt;+350&gt;:   sub    %gs:0x14,%eax</span><br><span class="line">0x000016da &lt;+357&gt;:   jne    0x16e8 &lt;phase_3+371&gt;</span><br></pre></td></tr></table></figure>
<p>跳转过来之后, 要求 <code>B = 0x68</code>, 也就是 <code>h</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x000016dc &lt;+359&gt;:   add    $0x18,%esp</span><br><span class="line">0x000016df &lt;+362&gt;:   pop    %ebx</span><br><span class="line">0x000016e0 &lt;+363&gt;:   ret</span><br><span class="line">0x000016e1 &lt;+364&gt;:   call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x000016e6 &lt;+369&gt;:   jmp    0x16cf &lt;phase_3+346&gt;</span><br><span class="line">0x000016e8 &lt;+371&gt;:   call   0x2a40 &lt;__stack_chk_fail_local&gt;</span><br></pre></td></tr></table></figure>
<p>因此本阶段密码为: <code>7 h 546</code>.</p>
<hr />
<h3 id="func4"><a class="markdownIt-Anchor" href="#func4"></a> <code>&lt;func4&gt;</code></h3>
<p>传入三个参数, 从栈顶往下, 设为 <code>A</code>, <code>B</code>, <code>C</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x000016ed &lt;+0&gt;:     push   %ebx</span><br><span class="line">0x000016ee &lt;+1&gt;:     sub    $0x8,%esp</span><br><span class="line">0x000016f1 &lt;+4&gt;:     mov    0x10(%esp),%eax</span><br><span class="line">0x000016f5 &lt;+8&gt;:     mov    0x18(%esp),%ecx</span><br><span class="line">0x000016f9 &lt;+12&gt;:    mov    %ecx,%edx</span><br><span class="line">0x000016fb &lt;+14&gt;:    sub    0x14(%esp),%edx</span><br><span class="line">0x000016ff &lt;+18&gt;:    mov    %edx,%ebx</span><br><span class="line">0x00001701 &lt;+20&gt;:    shr    $0x1f,%ebx</span><br><span class="line">0x00001704 &lt;+23&gt;:    add    %edx,%ebx</span><br><span class="line">0x00001706 &lt;+25&gt;:    sar    $1,%ebx</span><br><span class="line">0x00001708 &lt;+27&gt;:    add    0x14(%esp),%ebx</span><br></pre></td></tr></table></figure>
<p><code>%eax = A</code>, <code>%ecx = C</code>, <code>%edx = C - B</code>, <code>%ebx = (C - B) &gt;&gt; 31 + (C - B)</code>. (逻辑右移, 高位补 <code>0</code>)</p>
<p>这里 <code>%ebx</code> 的值本质上是 <code>C - B</code> 加上它的符号位.</p>
<p><code>%ebx = (%ebx &gt;&gt; 1) + B</code>. (算术右移, 高位补符号位)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x0000170c &lt;+31&gt;:    cmp    %eax,%ebx</span><br><span class="line">0x0000170e &lt;+33&gt;:    jg     0x1719 &lt;func4+44&gt;</span><br><span class="line">0x00001710 &lt;+35&gt;:    jl     0x1731 &lt;func4+68&gt;</span><br><span class="line">0x00001712 &lt;+37&gt;:    mov    %ebx,%eax</span><br><span class="line">0x00001714 &lt;+39&gt;:    add    $0x8,%esp</span><br><span class="line">0x00001717 &lt;+42&gt;:    pop    %ebx</span><br><span class="line">0x00001718 &lt;+43&gt;:    ret</span><br></pre></td></tr></table></figure>
<p>当 <code>%ebx = %eax = A</code> 时, 会用 <code>%eax</code> 返回 <code>%ebx</code> 的值.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x00001719 &lt;+44&gt;:    sub    $0x4,%esp</span><br><span class="line">0x0000171c &lt;+47&gt;:    lea    -0x1(%ebx),%edx</span><br><span class="line">0x0000171f &lt;+50&gt;:    push   %edx</span><br><span class="line">0x00001720 &lt;+51&gt;:    push   0x1c(%esp)</span><br><span class="line">0x00001724 &lt;+55&gt;:    push   %eax</span><br><span class="line">0x00001725 &lt;+56&gt;:    call   0x16ed &lt;func4&gt;</span><br><span class="line">0x0000172a &lt;+61&gt;:    add    $0x10,%esp</span><br><span class="line">0x0000172d &lt;+64&gt;:    add    %eax,%ebx</span><br><span class="line">0x0000172f &lt;+66&gt;:    jmp    0x1712 &lt;func4+37&gt;</span><br></pre></td></tr></table></figure>
<p>如果 <code>%ebx &gt; %eax</code>, 会递归调用 <code>&lt;func4&gt;</code>, <code>A' = %eax = A</code>, <code>B = B'</code>, <code>C' = %edx = %ebx - 1</code>, 将调用的返回值增加到 <code>%ebx</code> 中, 然后跳出函数.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x00001731 &lt;+68&gt;:    sub    $0x4,%esp</span><br><span class="line">0x00001734 &lt;+71&gt;:    push   %ecx</span><br><span class="line">0x00001735 &lt;+72&gt;:    lea    0x1(%ebx),%edx</span><br><span class="line">0x00001738 &lt;+75&gt;:    push   %edx</span><br><span class="line">0x00001739 &lt;+76&gt;:    push   %eax</span><br><span class="line">0x0000173a &lt;+77&gt;:    call   0x16ed &lt;func4&gt;</span><br><span class="line">0x0000173f &lt;+82&gt;:    add    $0x10,%esp</span><br><span class="line">0x00001742 &lt;+85&gt;:    add    %eax,%ebx</span><br><span class="line">0x00001744 &lt;+87&gt;:    jmp    0x1712 &lt;func4+37&gt;</span><br></pre></td></tr></table></figure>
<p><code>%ebx &lt; %eax</code> 也会递归, <code>A' = A</code>, <code>B' = %ebx + 1</code>, <code>C' = C</code>, 将返回值增加到 <code>%ebx</code> 中, 返回 <code>%ebx</code> 的值.</p>
<hr />
<h3 id="phase_4"><a class="markdownIt-Anchor" href="#phase_4"></a> <code>&lt;phase_4&gt;</code></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0x00001746 &lt;+0&gt;:     push   %ebx</span><br><span class="line">0x00001747 &lt;+1&gt;:     sub    $0x18,%esp</span><br><span class="line">0x0000174a &lt;+4&gt;:     call   0x1240 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">0x0000174f &lt;+9&gt;:     add    $0x4815,%ebx</span><br><span class="line">0x00001755 &lt;+15&gt;:    mov    %gs:0x14,%eax</span><br><span class="line">0x0000175b &lt;+21&gt;:    mov    %eax,0xc(%esp)</span><br><span class="line">0x0000175f &lt;+25&gt;:    xor    %eax,%eax</span><br><span class="line">0x00001761 &lt;+27&gt;:    lea    0x8(%esp),%eax</span><br><span class="line">0x00001765 &lt;+31&gt;:    push   %eax</span><br><span class="line">0x00001766 &lt;+32&gt;:    lea    0x8(%esp),%eax</span><br><span class="line">0x0000176a &lt;+36&gt;:    push   %eax</span><br><span class="line">0x0000176b &lt;+37&gt;:    lea    -0x2c85(%ebx),%eax</span><br><span class="line">0x00001771 &lt;+43&gt;:    push   %eax</span><br><span class="line">0x00001772 &lt;+44&gt;:    push   0x2c(%esp)</span><br><span class="line">0x00001776 &lt;+48&gt;:    call   0x1140 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">0x0000177b &lt;+53&gt;:    add    $0x10,%esp</span><br><span class="line">0x0000177e &lt;+56&gt;:    cmp    $0x2,%eax</span><br><span class="line">0x00001781 &lt;+59&gt;:    jne    0x178a &lt;phase_4+68&gt;</span><br><span class="line">0x00001783 &lt;+61&gt;:    cmpl   $0xe,0x4(%esp)</span><br><span class="line">0x00001788 &lt;+66&gt;:    jbe    0x178f &lt;phase_4+73&gt;</span><br><span class="line">0x0000178a &lt;+68&gt;:    call   0x1c39 &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>这里读入了两个数, 并且要求 <code>0x4(%esp)</code> 小于等于 <code>0xe = 14</code>. 在 <code>&lt;phase_4+53&gt;</code> 后, 读入的数字存储的位置应该是: <code>0x4(%esp)</code>, <code>0x8(%esp)</code>, 记为 <code>X</code>, <code>Y</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x0000178f &lt;+73&gt;:    sub    $0x4,%esp</span><br><span class="line">0x00001792 &lt;+76&gt;:    push   $0xe</span><br><span class="line">0x00001794 &lt;+78&gt;:    push   $0x0</span><br><span class="line">0x00001796 &lt;+80&gt;:    push   0x10(%esp)</span><br><span class="line">0x0000179a &lt;+84&gt;:    call   0x16ed &lt;func4&gt;</span><br><span class="line">0x0000179f &lt;+89&gt;:    add    $0x10,%esp</span><br></pre></td></tr></table></figure>
<p>这里调用了一个从命名看不出任何内容的函数 <code>&lt;func4&gt;</code>, 传入了三个参数, 从栈顶往下, 依次为: <code>X</code>, <code>0</code>, <code>14</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x000017a2 &lt;+92&gt;:    cmp    $0x7,%eax</span><br><span class="line">0x000017a5 &lt;+95&gt;:    jne    0x17ae &lt;phase_4+104&gt;</span><br></pre></td></tr></table></figure>
<p>这里可以发现, 需要调整 <code>X</code> 的值, 使得调用 <code>&lt;func4&gt;</code> 的返回值为 <code>7</code>.</p>
<p>调用 <code>&lt;func4&gt;(X, 0, 14)</code>, <code>%ebx</code> 在 <code>&lt;func4+27&gt;</code> 后等于 <code>7</code>, 所以只需令 <code>X = 7</code> 即可通过本阶段.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x000017a7 &lt;+97&gt;:    cmpl   $0x7,0x8(%esp)</span><br><span class="line">0x000017ac &lt;+102&gt;:   je     0x17b3 &lt;phase_4+109&gt;</span><br></pre></td></tr></table></figure>
<p>由此得出 <code>Y = 7</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x000017ae &lt;+104&gt;:   call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x000017b3 &lt;+109&gt;:   mov    0xc(%esp),%eax</span><br><span class="line">0x000017b7 &lt;+113&gt;:   sub    %gs:0x14,%eax</span><br><span class="line">0x000017be &lt;+120&gt;:   jne    0x17c5 &lt;phase_4+127&gt;</span><br><span class="line">0x000017c0 &lt;+122&gt;:   add    $0x18,%esp</span><br><span class="line">0x000017c3 &lt;+125&gt;:   pop    %ebx</span><br><span class="line">0x000017c4 &lt;+126&gt;:   ret</span><br><span class="line">0x000017c5 &lt;+127&gt;:   call   0x2a40 &lt;__stack_chk_fail_local&gt;</span><br></pre></td></tr></table></figure>
<p>综上本阶段答案为 <code>7 7</code>, 但是直觉上, 答案可能不唯一, 但是没有挖掘更多答案的必要.</p>
<hr />
<h3 id="phase_5"><a class="markdownIt-Anchor" href="#phase_5"></a> <code>&lt;phase_5&gt;</code></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0x000017ca &lt;+0&gt;:     push   %esi</span><br><span class="line">0x000017cb &lt;+1&gt;:     push   %ebx</span><br><span class="line">0x000017cc &lt;+2&gt;:     sub    $0x20,%esp</span><br><span class="line">0x000017cf &lt;+5&gt;:     call   0x1240 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">0x000017d4 &lt;+10&gt;:    add    $0x4790,%ebx</span><br><span class="line">0x000017da &lt;+16&gt;:    mov    0x2c(%esp),%esi</span><br><span class="line">0x000017de &lt;+20&gt;:    mov    %gs:0x14,%eax</span><br><span class="line">0x000017e4 &lt;+26&gt;:    mov    %eax,0x18(%esp)</span><br><span class="line">0x000017e8 &lt;+30&gt;:    xor    %eax,%eax</span><br><span class="line">0x000017ea &lt;+32&gt;:    push   %esi</span><br><span class="line">0x000017eb &lt;+33&gt;:    call   0x1b03 &lt;string_length&gt;</span><br><span class="line">0x000017f0 &lt;+38&gt;:    add    $0x10,%esp</span><br><span class="line">0x000017f3 &lt;+41&gt;:    cmp    $0x6,%eax</span><br><span class="line">0x000017f6 &lt;+44&gt;:    jne    0x184d &lt;phase_5+131&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;phase_5+16&gt;</code> 给 <code>%esi</code> 赋的值, 存储在调用 <code>&lt;phase_5&gt;</code> 前的栈顶位置, 也就是传入的参数, 输入的字符串头指针. 后面对这个字符串求长度, 存储在 <code>%eax</code>, 并且由 <code>&lt;phase_5+41&gt;</code> 推断输入字符串的长度必须是 <code>6</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x000017f8 &lt;+46&gt;:    mov    $0x0,%eax</span><br><span class="line">0x000017fd &lt;+51&gt;:    lea    -0x2da4(%ebx),%ecx</span><br><span class="line">0x00001803 &lt;+57&gt;:    movzbl (%esi,%eax,1),%edx</span><br><span class="line">0x00001807 &lt;+61&gt;:    and    $0xf,%edx</span><br><span class="line">0x0000180a &lt;+64&gt;:    movzbl (%ecx,%edx,1),%edx</span><br><span class="line">0x0000180e &lt;+68&gt;:    mov    %dl,0x5(%esp,%eax,1)</span><br><span class="line">0x00001812 &lt;+72&gt;:    add    $0x1,%eax</span><br><span class="line">0x00001815 &lt;+75&gt;:    cmp    $0x6,%eax</span><br><span class="line">0x00001818 &lt;+78&gt;:    jne    0x1803 &lt;phase_5+57&gt;</span><br><span class="line">0x0000181a &lt;+80&gt;:    movb   $0x0,0xb(%esp)</span><br></pre></td></tr></table></figure>
<p>通过访问内存, 得到 <code>%ecx</code> 字符串的前 <code>16</code> 个字节, <code>maduiersnfotvbyl</code>, 记这个字符串为 <code>List</code>.</p>
<p>这里是一个循环, 将字符串 <code>%esi</code> 的每一个字符 <code>%esi[i]</code> 与 <code>0xf</code> 也就是四个 <code>1</code> 的掩码后得到 <code>D</code>. 在字符串 <code>%ecx</code> 中, 取第 <code>D</code> 个字符, 放入 <code>%esp + i + 5</code> 中.</p>
<p>这样就使得 <code>%esp + 5</code> 到 <code>%esp + a</code> 共六个字节成为一个新的字符串, 所以最后在 <code>%esp + b</code> 赋 <code>0</code> 表示结束. 记这个串为 <code>T</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x0000181f &lt;+85&gt;:    sub    $0x8,%esp</span><br><span class="line">0x00001822 &lt;+88&gt;:    lea    -0x2dcd(%ebx),%eax</span><br><span class="line">0x00001828 &lt;+94&gt;:    push   %eax</span><br><span class="line">0x00001829 &lt;+95&gt;:    lea    0x11(%esp),%eax</span><br><span class="line">0x0000182d &lt;+99&gt;:    push   %eax</span><br><span class="line">0x0000182e &lt;+100&gt;:   call   0x1b21 &lt;strings_not_equal&gt;</span><br><span class="line">0x00001833 &lt;+105&gt;:   add    $0x10,%esp</span><br><span class="line">0x00001836 &lt;+108&gt;:   test   %eax,%eax</span><br><span class="line">0x00001838 &lt;+110&gt;:   jne    0x1854 &lt;phase_5+138&gt;</span><br></pre></td></tr></table></figure>
<p>在对 <code>%esp</code> 进行后续修改后, 伸长了 <code>b</code> 个字节, 所以 <code>b + 5 = 0x11</code>, <code>&lt;phase_5+95&gt;</code> 中赋给 <code>%eax</code> 的就是 <code>T</code> 的头指针.</p>
<p>访问内存获取参与比较的另一个字符串 <code>-0x2dcd(%ebx)</code>, 内容是 <code>flyers</code>, 记为 <code>S</code>.</p>
<p>在 <code>List</code> 中检索这个 <code>S</code>, 得到下标序列 <code>9, f, e, 5, 6, 7</code>, 需要找到六个字符, 使得他们的低四位是这几个数. 对于可打印字符, 可行的解有:</p>
<p><code>9</code>: <code>)9IYiy</code></p>
<p><code>f</code>: <code>/?O_o</code></p>
<p><code>e</code>: <code>.&gt;N^n~</code></p>
<p><code>5</code>: <code>%5EUeu</code></p>
<p><code>6</code>: <code>&amp;6FVfv</code></p>
<p><code>7</code>: <code>'7GWgw</code></p>
<p>这六组字符按顺序组成字符串理论上都可以作为答案, 随便取一组 <code>)_&gt;%&amp;'</code> 进行测试, 通过了本阶段.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x0000183a &lt;+112&gt;:   mov    0xc(%esp),%eax</span><br><span class="line">0x0000183e &lt;+116&gt;:   sub    %gs:0x14,%eax</span><br><span class="line">0x00001845 &lt;+123&gt;:   jne    0x185b &lt;phase_5+145&gt;</span><br><span class="line">0x00001847 &lt;+125&gt;:   add    $0x14,%esp</span><br><span class="line">0x0000184a &lt;+128&gt;:   pop    %ebx</span><br><span class="line">0x0000184b &lt;+129&gt;:   pop    %esi</span><br><span class="line">0x0000184c &lt;+130&gt;:   ret</span><br><span class="line">0x0000184d &lt;+131&gt;:   call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x00001852 &lt;+136&gt;:   jmp    0x17f8 &lt;phase_5+46&gt;</span><br><span class="line">0x00001854 &lt;+138&gt;:   call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x00001859 &lt;+143&gt;:   jmp    0x183a &lt;phase_5+112&gt;</span><br><span class="line">0x0000185b &lt;+145&gt;:   call   0x2a40 &lt;__stack_chk_fail_local&gt;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="phase_6"><a class="markdownIt-Anchor" href="#phase_6"></a> <code>&lt;phase_6&gt;</code></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0x00001860 &lt;+0&gt;:     push   %ebp</span><br><span class="line">0x00001861 &lt;+1&gt;:     push   %edi</span><br><span class="line">0x00001862 &lt;+2&gt;:     push   %esi</span><br><span class="line">0x00001863 &lt;+3&gt;:     push   %ebx</span><br><span class="line">0x00001864 &lt;+4&gt;:     sub    $0x74,%esp</span><br><span class="line">0x00001867 &lt;+7&gt;:     call   0x1240 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">0x0000186c &lt;+12&gt;:    add    $0x46f8,%ebx</span><br><span class="line">0x00001872 &lt;+18&gt;:    mov    %gs:0x14,%eax</span><br><span class="line">0x00001878 &lt;+24&gt;:    mov    %eax,0x64(%esp)</span><br><span class="line">0x0000187c &lt;+28&gt;:    xor    %eax,%eax</span><br><span class="line">0x0000187e &lt;+30&gt;:    lea    0x34(%esp),%eax</span><br><span class="line">0x00001882 &lt;+34&gt;:    mov    %eax,%edi</span><br><span class="line">0x00001884 &lt;+36&gt;:    mov    %eax,0x24(%esp)</span><br><span class="line">0x00001888 &lt;+40&gt;:    push   %eax</span><br><span class="line">0x00001889 &lt;+41&gt;:    push   0x8c(%esp)</span><br><span class="line">0x00001890 &lt;+48&gt;:    call   0x1c6e &lt;read_six_numbers&gt;</span><br></pre></td></tr></table></figure>
<p>调用 <code>&lt;read_six_numbers&gt;</code> 前, 栈顶下方一个长字, 就是读入数字存储的头指针, 即 <code>&lt;phase_6+30&gt;</code> 的 <code>%esp + 0x34</code>, 也就是 <code>&lt;phase_6+48&gt;</code> 时的 <code>%esp + 0x3c</code>. 设读入的数为 <code>A[0]</code>, <code>A[1]</code>, …, <code>A[5]</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x00001895 &lt;+53&gt;:    mov    %edi,0x28(%esp)</span><br><span class="line">0x00001899 &lt;+57&gt;:    add    $0x10,%esp</span><br><span class="line">0x0000189c &lt;+60&gt;:    mov    %edi,0x10(%esp)</span><br><span class="line">0x000018a0 &lt;+64&gt;:    movl   $0x0,0xc(%esp)</span><br><span class="line">0x000018a8 &lt;+72&gt;:    mov    %edi,%ebp</span><br><span class="line">0x000018aa &lt;+74&gt;:    jmp    0x18cf &lt;phase_6+111&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x000018ac &lt;+76&gt;:    call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x000018b1 &lt;+81&gt;:    jmp    0x18e3 &lt;phase_6+131&gt;</span><br><span class="line">0x000018b3 &lt;+83&gt;:    add    $0x1,%esi</span><br><span class="line">0x000018b6 &lt;+86&gt;:    cmp    $0x6,%esi</span><br><span class="line">0x000018b9 &lt;+89&gt;:    je     0x18ca &lt;phase_6+106&gt;</span><br><span class="line">0x000018bb &lt;+91&gt;:    mov    0x0(%ebp,%esi,4),%eax</span><br><span class="line">0x000018bf &lt;+95&gt;:    cmp    %eax,(%edi)</span><br><span class="line">0x000018c1 &lt;+97&gt;:    jne    0x18b3 &lt;phase_6+83&gt;</span><br><span class="line">0x000018c3 &lt;+99&gt;:    call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x000018c8 &lt;+104&gt;:   jmp    0x18b3 &lt;phase_6+83&gt;</span><br></pre></td></tr></table></figure>
<p>这是内层循环, 将 <code>%esi</code> 从 <code>0xc(%esp)</code> 枚举到 <code>5</code>, 记为 <code>j</code>.</p>
<p>从 <code>&lt;phase_6+95&gt;</code> 可以判断, <code>A[i + 1]</code> 到 <code>A[5]</code> 都不应该当等于 <code>A[i]</code>. 即, 六个数互不相同.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x000018ca &lt;+106&gt;:   addl   $0x4,0x10(%esp)</span><br><span class="line">0x000018cf &lt;+111&gt;:   mov    0x10(%esp),%eax</span><br><span class="line">0x000018d3 &lt;+115&gt;:   mov    %eax,%edi</span><br><span class="line">0x000018d5 &lt;+117&gt;:   mov    (%eax),%eax</span><br><span class="line">0x000018d7 &lt;+119&gt;:   mov    %eax,0x14(%esp)</span><br><span class="line">0x000018db &lt;+123&gt;:   sub    $0x1,%eax</span><br><span class="line">0x000018de &lt;+126&gt;:   cmp    $0x5,%eax</span><br><span class="line">0x000018e1 &lt;+129&gt;:   ja     0x18ac &lt;phase_6+76&gt;</span><br><span class="line">0x000018e3 &lt;+131&gt;:   addl   $0x1,0xc(%esp)</span><br><span class="line">0x000018e8 &lt;+136&gt;:   mov    0xc(%esp),%esi</span><br><span class="line">0x000018ec &lt;+140&gt;:   cmp    $0x5,%esi</span><br><span class="line">0x000018ef &lt;+143&gt;:   jle    0x18bb &lt;phase_6+91&gt;</span><br></pre></td></tr></table></figure>
<p>这是外层循环的一部分, 会将 <code>0x10(%esp)</code> 从 <code>A[0]</code> 的地址枚举到 <code>A[5]</code>. 从 <code>0</code> 到 <code>5</code> 枚举 <code>0xc(%esp)</code> 和 <code>%esi</code>, 记为 <code>i</code>.</p>
<p><code>&lt;phase_6+126&gt;</code> 要求 <code>%eax &lt;= 5</code>, 注意到这里的 <code>%eax</code> 在上一条指令中被减去了 <code>1</code>, 也就是 <code>&lt;phase_6+111&gt;</code> 中 <code>1 &lt;= (%eax) &lt;= 6</code>. 也就是读入的数字都在 <code>1</code> 到 <code>6</code> 之间.</p>
<p>结合内层循环的判断, 这里应当是输入一个 <code>6</code> 的排列.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x000018f1 &lt;+145&gt;:   mov    0x1c(%esp),%edx</span><br><span class="line">0x000018f5 &lt;+149&gt;:   add    $0x18,%edx</span><br><span class="line">0x000018f8 &lt;+152&gt;:   mov    $0x7,%ecx</span><br><span class="line">0x000018fd &lt;+157&gt;:   mov    0x18(%esp),%eax</span><br><span class="line">0x00001901 &lt;+161&gt;:   mov    %ecx,%esi</span><br><span class="line">0x00001903 &lt;+163&gt;:   sub    (%eax),%esi</span><br><span class="line">0x00001905 &lt;+165&gt;:   mov    %esi,(%eax)</span><br><span class="line">0x00001907 &lt;+167&gt;:   add    $0x4,%eax</span><br><span class="line">0x0000190a &lt;+170&gt;:   cmp    %eax,%edx</span><br><span class="line">0x0000190c &lt;+172&gt;:   jne    0x1901 &lt;phase_6+161&gt;</span><br></pre></td></tr></table></figure>
<p>这是一个循环, <code>%eax</code> 从 <code>A[0]</code> 的地址开始, 每次向后一个长字, 直到 <code>A[6]</code> 的地址 (不存在这个元素, 但是由 <code>&lt;phase_6+36&gt;</code>, <code>&lt;phase_6+145&gt;</code> 和 <code>&lt;phase_6+149&gt;</code> 得知 <code>%edx</code> 保存的地址指向这个位置, 循环过程中也不会访问这个地址) 然后令 <code>A[i] = 7 - A[i]</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x0000190e &lt;+174&gt;:   mov    $0x0,%esi</span><br><span class="line">0x00001913 &lt;+179&gt;:   mov    %esi,%edi</span><br><span class="line">0x00001915 &lt;+181&gt;:   mov    0x2c(%esp,%esi,4),%ecx</span><br><span class="line">0x00001919 &lt;+185&gt;:   mov    $0x1,%eax</span><br><span class="line">0x0000191e &lt;+190&gt;:   lea    0x168(%ebx),%edx</span><br><span class="line">0x00001924 &lt;+196&gt;:   cmp    $0x1,%ecx</span><br><span class="line">0x00001927 &lt;+199&gt;:   jle    0x1933 &lt;phase_6+211&gt;</span><br><span class="line">0x00001929 &lt;+201&gt;:   mov    0x8(%edx),%edx</span><br><span class="line">0x0000192c &lt;+204&gt;:   add    $0x1,%eax</span><br><span class="line">0x0000192f &lt;+207&gt;:   cmp    %ecx,%eax</span><br><span class="line">0x00001931 &lt;+209&gt;:   jne    0x1929 &lt;phase_6+201&gt;</span><br><span class="line">0x00001933 &lt;+211&gt;:   mov    %edx,0x44(%esp,%edi,4)</span><br><span class="line">0x00001937 &lt;+215&gt;:   add    $0x1,%esi</span><br><span class="line">0x0000193a &lt;+218&gt;:   cmp    $0x6,%esi</span><br><span class="line">0x0000193d &lt;+221&gt;:   jne    0x1913 &lt;phase_6+179&gt;</span><br></pre></td></tr></table></figure>
<p>这是一个二重循环, 将 <code>%esi</code> 从 <code>0</code> 枚举到 <code>5</code>. 有一个新数组 <code>0x44(%esp)</code> 记为 <code>B</code>. 新建一个变量 <code>j = 1</code>, <code>k = %ebx + 0x168</code>. 如果 <code>A[i] &lt;= j</code> 就令 <code>B[i] = k</code>, 否则 <code>++j</code>, 令 <code>k = *(k + 0x8)</code>.</p>
<p><code>%ebx + 0x168 = 0x5655b0cc</code> 和之后的几个长字的值为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x5655b068: 0x56</span><br><span class="line"></span><br><span class="line">0x5655b0cc &lt;node1&gt;:     0x0000008d      0x00000001      0x5655b0d8      0x00000131</span><br><span class="line">0x5655b0dc &lt;node2+4&gt;:   0x00000002      0x5655b0e4      0x00000353      0x00000003</span><br><span class="line">0x5655b0ec &lt;node3+8&gt;:   0x5655b0f0      0x00000237      0x00000004      0x5655b0fc</span><br><span class="line">0x5655b0fc &lt;node5&gt;:     0x00000312      0x00000005      0x5655b068      0x00000000</span><br></pre></td></tr></table></figure>
<p>我们可以尝试写出 <code>k</code> 的取值顺序: <code>0x5655b0cc, 0x5655b0d8, 0x5655b0e4, 0x5655b0f0, 0x5655b0fc, 0x5655b068</code>, 因为 <code>A[i]</code> 最多是 <code>6</code> 所以 <code>k</code> 的取值也只会迭代到第六次. 记第 <code>i</code> 个取值为 <code>k[i]</code>, 则经过这个循环后, <code>0x44(%esp)</code> 的值会变成 <code>B[i] = k[A[i] - 1]</code>.</p>
<p>可以认为, 从 <code>B[i]</code> 指向的字节开始的 <code>12</code> 个字节, 是一个结构体单元, 其中, 最后的四个字节表示一个指针, 表示它后继的头指针, 而开始的四个字节则存储该单元的权值.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x0000193f &lt;+223&gt;:   mov    0x44(%esp),%esi</span><br><span class="line">0x00001943 &lt;+227&gt;:   mov    0x48(%esp),%eax</span><br><span class="line">0x00001947 &lt;+231&gt;:   mov    %eax,0x8(%esi)</span><br><span class="line">0x0000194a &lt;+234&gt;:   mov    0x4c(%esp),%edx</span><br><span class="line">0x0000194e &lt;+238&gt;:   mov    %edx,0x8(%eax)</span><br><span class="line">0x00001951 &lt;+241&gt;:   mov    0x50(%esp),%eax</span><br><span class="line">0x00001955 &lt;+245&gt;:   mov    %eax,0x8(%edx)</span><br><span class="line">0x00001958 &lt;+248&gt;:   mov    0x54(%esp),%edx</span><br><span class="line">0x0000195c &lt;+252&gt;:   mov    %edx,0x8(%eax)</span><br><span class="line">0x0000195f &lt;+255&gt;:   mov    0x58(%esp),%eax</span><br><span class="line">0x00001963 &lt;+259&gt;:   mov    %eax,0x8(%edx)</span><br><span class="line">0x00001966 &lt;+262&gt;:   movl   $0x0,0x8(%eax)</span><br></pre></td></tr></table></figure>
<p>从 <code>B[0]</code> 到 <code>B[5]</code>, 执行 <code>*(B[i] + 8) = B[i + 1]</code>, <code>*(B[5] + 8) = 0</code>. 这里可以理解为重新赋值每个存储单元的后继指针.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x0000196d &lt;+269&gt;:   mov    $0x5,%edi</span><br><span class="line">0x00001972 &lt;+274&gt;:   jmp    0x197c &lt;phase_6+284&gt;</span><br><span class="line">0x00001974 &lt;+276&gt;:   mov    0x8(%esi),%esi</span><br><span class="line">0x00001977 &lt;+279&gt;:   sub    $0x1,%edi</span><br><span class="line">0x0000197a &lt;+282&gt;:   je     0x198c &lt;phase_6+300&gt;</span><br><span class="line">0x0000197c &lt;+284&gt;:   mov    0x8(%esi),%eax</span><br><span class="line">0x0000197f &lt;+287&gt;:   mov    (%eax),%eax</span><br><span class="line">0x00001981 &lt;+289&gt;:   cmp    %eax,(%esi)</span><br><span class="line">0x00001983 &lt;+291&gt;:   jge    0x1974 &lt;phase_6+276&gt;</span><br><span class="line">0x00001985 &lt;+293&gt;:   call   0x1c39 &lt;explode_bomb&gt;</span><br><span class="line">0x0000198a &lt;+298&gt;:   jmp    0x1974 &lt;phase_6+276&gt;</span><br></pre></td></tr></table></figure>
<p>从 <code>5</code> 到 <code>0</code> 枚举 <code>edi</code>, 控制该结构执行五次.</p>
<p>需要保证每一次 <code>*%esi &gt;= %eax</code>. 这里 <code>%esi</code> 的初始值是 <code>B[0]</code>, 每次迭代到它的后继. <code>%eax</code> 则是其后继的权值. 也就是说后继的权值小于等于自己的权值.</p>
<p>重新审视挖掘出来的字节信息, 每一个单元的权值分别为, <code>0x8d, 0x131, 0x353, 0x237, 0x312, 0x56</code>, 如果要将其降序排列, 经过前面操作的排列应该是: <code>3 5 4 2 1 6</code>.</p>
<p>考虑到之前存在操作, 使得所有 <code>A[i] = 7 - A[i]</code>, 所以推断本题答案为: <code>4 2 3 5 6 1</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x0000198c &lt;+300&gt;:   mov    0x5c(%esp),%eax</span><br><span class="line">0x00001990 &lt;+304&gt;:   sub    %gs:0x14,%eax</span><br><span class="line">0x00001997 &lt;+311&gt;:   jne    0x19a1 &lt;phase_6+321&gt;</span><br><span class="line">0x00001999 &lt;+313&gt;:   add    $0x6c,%esp</span><br><span class="line">0x0000199c &lt;+316&gt;:   pop    %ebx</span><br><span class="line">0x0000199d &lt;+317&gt;:   pop    %esi</span><br><span class="line">0x0000199e &lt;+318&gt;:   pop    %edi</span><br><span class="line">0x0000199f &lt;+319&gt;:   pop    %ebp</span><br><span class="line">0x000019a0 &lt;+320&gt;:   ret</span><br><span class="line">0x000019a1 &lt;+321&gt;:   call   0x2a40 &lt;__stack_chk_fail_local&gt;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="一组可行的解"><a class="markdownIt-Anchor" href="#一组可行的解"></a> 一组可行的解</h2>
<p><img src="/images/Binary_Bomb.png" alt="" /></p>
<p>阶段五存在其它的解, 阶段四可能存在其它的解, 并且据说本实验还有隐藏关, 这次实验没有进行挖掘.</p>

                        </div>

                        <!-- Post Comments -->
                        
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'Micheal'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://wild-donkey.github.io/Engineering/Binary_Bomb/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://wild-donkey.github.io/Engineering/Binary_Bomb/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//Micheal.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


                      </div>
                      <!-- Copyright 版权 start -->
                              <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
                </div>
              </body>


              
 	
</html>
