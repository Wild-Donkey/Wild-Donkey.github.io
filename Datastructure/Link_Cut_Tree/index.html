<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Mild_Donkey
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="Mild_Donkey" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head>
    
		<!-- Layouts -->



              <!--  代码渲染  -->
              <link rel="stylesheet" href="/css/prism_coy.css" />
              <link rel="stylesheet" href="/css/typo.css" />
              <!-- 文章页 -->

              <body class>
                <!-- Wrapper 外包 s-->
                <div id="wrapper" class="fade-in">
                  <!-- Intro 头部显示 s -->
                  <!-- Intro 头部显示 e -->
                  <!-- Header 头部logo start -->
                  <header id="header">
    <a href="/" class="logo">Think Different</a>
</header>
                    <!-- Nav 导航条 start -->
                    <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">Home</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">Categories</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/AlgoRhythm/">AlgoRhythm</a></li><li><a class="category-link" href="/categories/Contests/">Contests</a></li><li><a class="category-link" href="/categories/Datastructure/">Datastructure</a></li><li><a class="category-link" href="/categories/Engineering/">Engineering</a></li><li><a class="category-link" href="/categories/Essays/">Essays</a></li><li><a class="category-link" href="/categories/Mathematics/">Mathematics</a></li><li><a class="category-link" href="/categories/Music/">Music</a></li><li><a class="category-link" href="/categories/Notes/">Notes</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        <li class="active">
	            <a href="#s1">Archives</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="archive-link" href="/archives/2024/10/">October 2024</a></li><li><a class="archive-link" href="/archives/2024/06/">June 2024</a></li><li><a class="archive-link" href="/archives/2023/10/">October 2023</a></li><li><a class="archive-link" href="/archives/2023/08/">August 2023</a></li><li><a class="archive-link" href="/archives/2023/05/">May 2023</a></li><li><a class="archive-link" href="/archives/2022/08/">August 2022</a></li><li><a class="archive-link" href="/archives/2022/07/">July 2022</a></li><li><a class="archive-link" href="/archives/2022/06/">June 2022</a></li><li><a class="archive-link" href="/archives/2022/05/">May 2022</a></li><li><a class="archive-link" href="/archives/2022/04/">April 2022</a></li><li><a class="archive-link" href="/archives/2022/03/">March 2022</a></li><li><a class="archive-link" href="/archives/2022/02/">February 2022</a></li><li><a class="archive-link" href="/archives/2022/01/">January 2022</a></li><li><a class="archive-link" href="/archives/2021/11/">November 2021</a></li><li><a class="archive-link" href="/archives/2021/10/">October 2021</a></li><li><a class="archive-link" href="/archives/2021/08/">August 2021</a></li><li><a class="archive-link" href="/archives/2021/05/">May 2021</a></li><li><a class="archive-link" href="/archives/2020/11/">November 2020</a></li><li><a class="archive-link" href="/archives/1978/10/">October 1978</a>
	                    </ul>
	        </li>
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="About">
		                About
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="Friends">
		                Friends
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="Gallery">
		                Gallery
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="Tags">
		                Tags
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/Wild-Donkey" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

                      <div id="main">
                        <div class="post_page_title_img"
                          style="height: 25rem;background-image: url(/images/Location.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                          <a href="#" style="padding: 4rem 4rem 2rem 4rem ;">
                            <h2>
                              LCT
                            </h2>
                          </a>
                        </div>
                        <!-- Post -->
                        <div class="typo" style="padding: 3rem;">
                          <h1 id="linkcut-tree-动态树"><a class="markdownIt-Anchor" href="#linkcut-tree-动态树"></a> Link/Cut Tree (动态树)</h1>
<p>动态树问题, 维护一个森林, 支持但不仅限于如下操作:</p>
<ul>
<li>
<p>Query</p>
<p>查询路径信息.</p>
</li>
<li>
<p>Link</p>
<p>连接两个不同树上的点.</p>
</li>
<li>
<p>Cut</p>
<p>断开两点之间的连边.</p>
</li>
<li>
<p>Change</p>
<p>单点修改</p>
</li>
</ul>
<p>给出的解决方案是 Link/Cut Tree, 基于 Splay 的数据结构, 简称 LCT.</p>
<p>关于 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/Wild-Donkey/ren-lun-zhi-guang-splay">Splay</a> 的内容.</p>
<p>LCT 是对原树进行树链剖分后用 Splay 树 (以下简称 Splay) 维护树链的数据结构, 这里的树链剖分指实链剖分, 如果你还不会轻重链剖分, 请先学习<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/Wild-Donkey/qing-zhong-lian-pou-fen">轻重链剖分</a>, 因为轻重链剖分是最简单的树链剖分.</p>
<h2 id="lct"><a class="markdownIt-Anchor" href="#lct"></a> LCT</h2>
<p>对于一棵树, 对它建立 LCT. LCT 也是一棵树, 是由若干 Splay 组成的.</p>
<p>原树上的边划分为两种, 实边和虚边. 在原树中, 每个节点最多只能有一条连接自己和儿子的实边 (注意, 也可以没有, 这里是区别于轻重链剖分的地方), 其余都是虚边. 原树可以被分成若干实链 (实边连接的极大链, 也就是将虚边去掉后剩下的若干连通块).</p>
<p>LCT 就是对每个实链建立 Splay, 然后用虚边将 Splay 连接起来. 根据树链剖分的原理得, 原树每个实链是竖直的, 即两端点的 LCA 必然是其中一个. 所以对于一条实链, 它的节点的深度是连续的, 从链顶到链底递增.</p>
<p>规定 Splay 的中序遍历递增的权值为 Splay 的性质权值, 也就是 Splay 的 BST 的 Key. LCT 中每个 Splay 的性质权值就是每个节点在原树中的深度.</p>
<p>对于 LCT 上的虚边, 可以理解成单向边, 从一棵 Splay 的根引出, 连向另一棵 Splay 的节点. 连边的原则是: LCT 中的一棵 Splay 的根连向它在原树中所在实链链顶的连接父亲的虚边连接的那个节点在 LCT 中的节点. 可能有些绕, 换个角度理解. 先规定父端点指虚边深度大的端点, 另一个端点即为子端点. 原树的虚边和 LCT 中的虚边一一对应, 原树虚边的父端点在 LCT 中不变, LCT 中父端点还是原树父端点在 LCT 中对应的点. 子端点发生改变, LCT 中, 一条虚边的子端点是原树的子端点对应节点所在的 Splay 的根.</p>
<p>根据一棵 LCT 可以构造出唯一的一棵树. 这是因为每个 Splay 构造出的实链是唯一的, 而实链的连接方式, 即虚边也是确定的. 因为它的父端点是确定的, 就是 LCT 中虚边父端点对应的节点, 子节点也是确定的, 因为实链的链顶是确定的.</p>
<p>因此我们完全可以用 LCT 来存原树, 无需再保存原树. 对于原树链上的信息, 直接通过 LCT 查询, 修改. 后面说的关于原树的操作只是一个模型便于理解, 至于实现, 则完全是在 LCT 上的操作.</p>
<p>使 LCT 强于轻重链剖分和并查集的是它可以使原树的边在虚实间变换, 来实现两棵树的连接, 树的换根等操作.</p>
<p>本文默认读者已经掌握了 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/Wild-Donkey/ren-lun-zhi-guang-splay">Splay</a> 的所有操作.</p>
<h2 id="虚实"><a class="markdownIt-Anchor" href="#虚实"></a> 虚实</h2>
<p>对于存边的方式, 由于不存原树, 所以只要考虑 LCT 上的实虚边怎么存即可.</p>
<p>对于实边, 就像 Splay 中那样, 每个点保存 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Fa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">a</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">RS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 三个指针. 但是虚边就很特殊, 因为每个点可以和若干虚边相连, 这就要用到邻接表.</p>
<p>但是懒出名的我曾经在写 AC 自动机的时候都坚决不写邻接表 (结果最后还是不得不写), 这次必然会想办法偷懒. 先说结论, 因为 LCT 上的每个操作需要通过虚边走到别的点的时候, 都是从下到上访问的, 所以可以之存指向父亲的单向边. 而每个节点只有一个父亲, 所以每个点存一个指针就能避免边表.</p>
<p>你的虚边指针, 何必额外定义, 思考实边中指向父亲的指针是否能够胜任. 首先, 指向父亲的边非实即虚, 也就是虚实不会冲突. 其次, 可以判断一个指向父亲的边是虚还是实, 只要一个节点不是父亲的左儿子也不是右儿子, 那么就可以鉴定这个指针是实还是虚.</p>
<p>所以一个边是虚边, 只要存儿子的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Fa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">a</span></span></span></span> 指针即可. 这种做法不仅节省空间, 优化常数, 在虚实转换时只要连/断儿子指针即可, 非常方便.</p>
<p>接下来介绍操作原理, 先从结构操作讲起, 这一部分是 LCT 的形态结构的各种变换.</p>
<h2 id="access"><a class="markdownIt-Anchor" href="#access"></a> Access</h2>
<p>LCT 的核心, 可以将原树中根到某点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的路径变成实链. 在 LCT 中体现就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 出现在了根所在的 Splay 的右端. 这里提到的 Splay 的端点即为性质权值的最值对应的节点, LCT 中 Splay 的右端点就是原树中实链的链底.</p>
<p>考虑原树上的改变. 先把所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">Root-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 路径上的边变实, 然后变虚多余的边. 即将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">Root-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 路径上所有点原来的实儿子变虚, 然后将路径上的边变实.</p>
<p>考虑从树上从根出发寻找到达某节点的路径的困难, 所以选择从节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 出发寻找前往根的路径 (闷头朝浅的地方走, 一定简单).</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 所在的实链中, 在 <code>Access(x)</code> 后仍在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的实链中的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和它的祖先们, 当 <code>Splay(x)</code> 后, 这一部分在 LCT 中就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和它的左子树, 而右子树则变成一条新的实链. 因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 到儿子的实链 (如果是虚链, 则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 本来就是链底, 也就没有右子树了) 必须变虚, 否则 <code>Access(x)</code> 后, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 所在的实链链底就不是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 了.</p>
<p>当对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 所在的 Splay 操作完后, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 成为了实链底, 然后从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 所在的实链继续往上连接. 设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">x&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 当前所在实链链顶. 因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">x&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 和父亲以虚边连接, 而 <code>Access(x)</code> 要求这条虚边变实, 首先要将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><msub><mi>a</mi><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></msub></mrow><annotation encoding="application/x-tex">Fa_{x&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32797999999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的已经连接的连向儿子的实边变虚, 即对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><msub><mi>a</mi><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></msub></mrow><annotation encoding="application/x-tex">Fa_{x&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32797999999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 进行 Splay 后, 分离右子树. 这时将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">x&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 的实边连过去, 也就是将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">x&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 所在 Splay 的根节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><msub><mi>a</mi><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></msub></mrow><annotation encoding="application/x-tex">Fa_{x&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32797999999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的右儿子. 这样一来, 整个的这一棵 Splay 代表实链的就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 到原来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><msub><mi>a</mi><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></msub></mrow><annotation encoding="application/x-tex">Fa_{x&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32797999999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 链顶的一条链了. 以此类推, 直到链顶变成树根为止.</p>
<h2 id="make_root"><a class="markdownIt-Anchor" href="#make_root"></a> Make_Root</h2>
<p>换根操作是基于 Access 的操作, 它也是 LCT 各种操作的基础.</p>
<p>先看 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">Root-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 链上的, 都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的直系祖先, 它们的父子关系直接反转, 变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>R</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">x-Root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 链, 剩下的点都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">Root-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 链上节点的子树, 而原来它们是谁的子树, <code>Make_Root(x)</code> 后还是谁的子树.</p>
<p>总结起来就是: 除了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">Root-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 链的边的父子关系发生改变, 其余节点都不受影响.</p>
<p>LCT 上实现做法很简单, 如果想要将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 设为根, 首先 <code>Access(x)</code>, 然后 <code>Splay(x)</code>. 好的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 就变成 LCT 的根了, 操作结束. (自欺欺人行为)</p>
<p>上面的操作只是将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 变成 LCT 的根, 但是 <code>Make_Root(x)</code> 的目的是把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 变成原树的根, 所以还没有结束.</p>
<p>这时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 作为所在 Splay 的右端点, 又是根节点, 所以一定没有右子树, 假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 有左子树. (如果没有左子树, 说明整个实链只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 一个点, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 本来就是原树根, 直接跳出就可以了), 如果希望反转整个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">Root-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 链, 可以像文艺平衡树中的操作一样, 反转整个 Splay.</p>
<p>对于 Splay 的反转, 为了保证复杂度, 需要一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">Tag</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>, 每次调用这个节点的时候再反转它的两个儿子, 这就牵扯到下面几个操作了.</p>
<h2 id="tag-management"><a class="markdownIt-Anchor" href="#tag-management"></a> Tag Management</h2>
<p>反转标记和线段树的累加标记不同, 它类似于按动开关, 按一下是开, 再按一下是关, 所以使用位运算对 Tag 进行操作.</p>
<p>一共有两种实现方式, 一种是在 Tag 存在时已经交换了两棵子树, 一种是 Tag 在的时候还没有交换两棵子树. 体现在程序中就是在 <code>Make_Tag</code> 时交换子树, 和在 <code>Push_Down</code> 中交换子树的区别.</p>
<p>为了常数, 我选择后者.</p>
<h3 id="make_tagx"><a class="markdownIt-Anchor" href="#make_tagx"></a> <code>Make_Tag(x)</code></h3>
<p>对某个点的整个子树进行反转, 需要对每个点的子树进行交换. 这时只在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 上打上标记, 剩下的都不用管.</p>
<p>打标记就是将原来的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">Tag</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 亦或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 每次改变 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">Tag</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 的状态.</p>
<h3 id="push_downx"><a class="markdownIt-Anchor" href="#push_downx"></a> <code>Push_Down(x)</code></h3>
<ul>
<li>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>g</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">Tag = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></p>
<p>无需操作.</p>
</li>
<li>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>g</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">Tag = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></p>
<p>交换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 左右儿子的指针, 然后对两个儿子 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>a</mi><mi>k</mi><msub><mi>e</mi><mi>T</mi></msub><mi>a</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">Make_Tag</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span></p>
</li>
</ul>
<h2 id="find_root"><a class="markdownIt-Anchor" href="#find_root"></a> Find_Root</h2>
<p>寻根, 用来判断两点的连通性, 只要所在原树树根相同, 则两点在一棵树上. 这颇似用并查集维护的集合, 只要对比并查集的编号就可查询两个元素是否在同一集合内.</p>
<p>操作也很简单, 寻找节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的根时, <code>Access(x)</code>, <code>Splay(x)</code>, 这时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和它的根在同一棵 Splay 内. 根一定是深度最小的, 所以一定位于 Splay 左端. 所以从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 出发一直左转, 直到没有左儿子为止, 这个点就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的根.</p>
<h2 id="link"><a class="markdownIt-Anchor" href="#link"></a> Link</h2>
<p>对两个节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 执行 <code>Link(x, y)</code> 操作, 分两种情况讨论.</p>
<p>对两点是否连通的判断可以通过 <code>Make_Root(x)</code> 后判断 <code>Find_Root(y)</code> 是否等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 来实现.</p>
<ul>
<li>
<p>两点在同一棵树上</p>
<p>这时两点连通, 无需操作.</p>
</li>
<li>
<p>两点在不在同一棵树上</p>
<p>在两点间连边, 考虑如何在连边时维护 LCT 性质. 这时, 因为判断重复时用到了 <code>Make_Root(x)</code>, <code>Find_Root(y)</code> 所以这时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是原树的树根, 也是对应 LCT 的树根. 这时将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 连一条虚边向 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>, 因为这样不用考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的儿子分布. 并且也满足原树中边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的出现.</p>
<p>所以操作就是判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 不连通后, 直接将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 置为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的父亲.</p>
</li>
</ul>
<h2 id="cut"><a class="markdownIt-Anchor" href="#cut"></a> Cut</h2>
<p>这个操作只针对有直接连边的两点, 所以仍然首先讨论连通性.</p>
<ul>
<li>
<p>两点在不在同一棵树上</p>
<p>这时根本就不连通, 无需操作.</p>
</li>
<li>
<p>两点在同一棵树上</p>
<p>这时 <code>Make_Root(x)</code>, <code>Access(y)</code>, 两点在原树中是某实链的两端. 如果有直接连边, 则两点在 Splay 中, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的左儿子, 且没有其它的点在这个 Splay 中. 否则没有连边, 直接跳出.</p>
<p>对于有连边的情况, 直接断开 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的实边连接, 将点数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的 Splay 分成两棵点数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的 Splay, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 分别为两棵新的原树的根节点, 操作完成.</p>
</li>
</ul>
<p>接下来是信息操作, 这一部分是运用 LCT 维护数据的操作.</p>
<p>在每个节点上维护 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>, 分别表示这个点的数据权值 (相对于性质权值而言), 和这个点子树上数据权值之和.</p>
<p>至于变换时维护 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 的数值, 则留在了代码实现的部分, 我们默认在调用时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 的值已经 Up to date 就可以了.</p>
<h2 id="query"><a class="markdownIt-Anchor" href="#query"></a> Query</h2>
<p>查询路径 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 上的权值和, 保证两点连通.</p>
<p>首先要 <code>Make_Root(x)</code>, <code>Access(y)</code>, 这时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 在一个 Splay 内, 查询这个 Splay 的根的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 即可.</p>
<h2 id="change"><a class="markdownIt-Anchor" href="#change"></a> Change</h2>
<p>为了方便维护 Sum, 直接 <code>Splay(x)</code>, 修改 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>.</p>
<h2 id="代码实现-模板-luogu-p3690"><a class="markdownIt-Anchor" href="#代码实现-模板-luogu-p3690"></a> 代码实现 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3690">模板 Luogu P3690</a></h2>
<p>维护一个森林, 支持四个操作:</p>
<ul>
<li>
<p>Query</p>
<p>为了考虑精度, 查询路径异或和.</p>
</li>
<li>
<p>Change</p>
<p>直接修改单点的权值.</p>
</li>
<li>
<p>Link</p>
<p>判断连通, 如果不连通就连边.</p>
</li>
<li>
<p>Cut</p>
<p>判断是否有连边, 有连边就断开.</p>
</li>
</ul>
<p>一开始给 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个单点, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq n \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>分函数分别解析, 虽然有些函数和 Splay 同名, 但是有部分不同点.</p>
<h3 id="update"><a class="markdownIt-Anchor" href="#update"></a> <code>Update()</code></h3>
<p>用一个点的儿子更新这个点的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>, 注意考虑儿子为空的情况.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">  x-&gt;Sum = x-&gt;Value;</span><br><span class="line">  <span class="keyword">if</span>(x-&gt;Son[<span class="number">0</span>]) &#123;</span><br><span class="line">    x-&gt;Sum ^= x-&gt;Son[<span class="number">0</span>]-&gt;Sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x-&gt;Son[<span class="number">1</span>]) &#123;</span><br><span class="line">    x-&gt;Sum ^= x-&gt;Son[<span class="number">1</span>]-&gt;Sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="push_down"><a class="markdownIt-Anchor" href="#push_down"></a> <code>Push_Down()</code></h3>
<p>下传标记, 前面提到过, 选取常数较小的写法. 每次打 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">Tag</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 之前, 只改变 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">Tag</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>, 不交换儿子.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Push_Down</span><span class="params">(Node *x)</span> </span>&#123;  <span class="comment">// Push_Down the spliting tag</span></span><br><span class="line">  <span class="keyword">if</span>(x-&gt;Tag) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">register</span> Node *<span class="title">TmpSon</span><span class="params">(x-&gt;Son[<span class="number">0</span>])</span></span>;</span><br><span class="line">    x-&gt;Tag = <span class="number">0</span>, x-&gt;Son[<span class="number">0</span>] = x-&gt;Son[<span class="number">1</span>], x-&gt;Son[<span class="number">1</span>] = TmpSon; </span><br><span class="line">    <span class="keyword">if</span>(x-&gt;Son[<span class="number">0</span>]) &#123;</span><br><span class="line">      x-&gt;Son[<span class="number">0</span>]-&gt;Tag ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;Son[<span class="number">1</span>]) &#123;</span><br><span class="line">      x-&gt;Son[<span class="number">1</span>]-&gt;Tag ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rotate"><a class="markdownIt-Anchor" href="#rotate"></a> <code>Rotate()</code></h3>
<p>和单独的 Splay 中的写法差别不大, 将 Splay 维护的 <code>Size</code> 转换为 LCT 中维护的 <code>Sum</code> 即可.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Rotate</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">register</span> Node *<span class="title">Father</span><span class="params">(x-&gt;Fa)</span></span>;</span><br><span class="line">  x-&gt;Fa = Father-&gt;Fa; <span class="comment">// x link to grandfather</span></span><br><span class="line">  <span class="keyword">if</span>(Father-&gt;Fa) &#123;</span><br><span class="line">    <span class="keyword">if</span>(Father-&gt;Fa-&gt;Son[<span class="number">0</span>] == Father) &#123;</span><br><span class="line">      Father-&gt;Fa-&gt;Son[<span class="number">0</span>] = x;  <span class="comment">// grandfather link to x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Father-&gt;Fa-&gt;Son[<span class="number">1</span>] == Father) &#123;</span><br><span class="line">      Father-&gt;Fa-&gt;Son[<span class="number">1</span>] = x;  <span class="comment">// grandfather link to x</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  x-&gt;Sum = <span class="number">0</span>, Father-&gt;Fa = x;</span><br><span class="line">  <span class="keyword">if</span>(Father-&gt;Son[<span class="number">0</span>] == x) &#123;</span><br><span class="line">    Father-&gt;Son[<span class="number">0</span>] = x-&gt;Son[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(Father-&gt;Son[<span class="number">0</span>]) &#123;</span><br><span class="line">      Father-&gt;Son[<span class="number">0</span>]-&gt;Fa = Father;</span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;Son[<span class="number">1</span>] = Father;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;Son[<span class="number">0</span>]) &#123;</span><br><span class="line">      x-&gt;Sum = x-&gt;Son[<span class="number">0</span>]-&gt;Sum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Father-&gt;Son[<span class="number">1</span>] = x-&gt;Son[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(Father-&gt;Son[<span class="number">1</span>]) &#123;</span><br><span class="line">      Father-&gt;Son[<span class="number">1</span>]-&gt;Fa = Father;</span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;Son[<span class="number">0</span>] = Father;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;Son[<span class="number">1</span>]) &#123;</span><br><span class="line">      x-&gt;Sum = x-&gt;Son[<span class="number">1</span>]-&gt;Sum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Update</span>(Father);</span><br><span class="line">  x-&gt;Sum ^= x-&gt;Value ^ Father-&gt;Sum;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="splay"><a class="markdownIt-Anchor" href="#splay"></a> <code>Splay()</code></h3>
<p>和纯 Splay 中的写法有很大不同, 因为 LCT 中的 Splay 是带有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>p</mi><mi>l</mi><mi>i</mi><msub><mi>t</mi><mi>T</mi></msub><mi>a</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">Split_Tag</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 的, 所以需要在 Splay 之前提前从上到下 <code>Push_Down()</code> 所经历的链. 为了从上到下遍历, 用栈存储回溯路径.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Splay</span> <span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">register</span> <span class="type">unsigned</span> <span class="title">Head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (x-&gt;Fa) &#123;                                       <span class="comment">// 父亲没到头</span></span><br><span class="line">    <span class="keyword">if</span>(x-&gt;Fa-&gt;Son[<span class="number">0</span>] == x || x-&gt;Fa-&gt;Son[<span class="number">1</span>] == x) &#123;      <span class="comment">// x is the preferred-edge linked son (实边连接的儿子)</span></span><br><span class="line">      Stack[++Head] = x;</span><br><span class="line">      x = x-&gt;Fa;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Push_Down</span>(x);</span><br><span class="line">  <span class="keyword">if</span>(Head) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">unsigned</span> <span class="built_in">i</span>(Head); i &gt; <span class="number">0</span>; --i) &#123;<span class="comment">//Must be sure there&#x27;s no tags alone Root-x, and delete Root-&gt;Fa for a while </span></span><br><span class="line">      <span class="built_in">Push_Down</span>(Stack[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    x = Stack[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;Fa) &#123;                                     <span class="comment">// 父亲没到头</span></span><br><span class="line">      <span class="keyword">if</span>(x-&gt;Fa-&gt;Son[<span class="number">0</span>] == x || x-&gt;Fa-&gt;Son[<span class="number">1</span>] == x) &#123;  <span class="comment">// x is the preferred-edge linked son (实边连接的儿子)</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;Fa-&gt;Fa) &#123;</span><br><span class="line">          <span class="keyword">if</span> (x-&gt;Fa-&gt;Fa-&gt;Son[<span class="number">0</span>] == x-&gt;Fa || x-&gt;Fa-&gt;Fa-&gt;Son[<span class="number">1</span>] == x-&gt;Fa) &#123; <span class="comment">// Father</span></span><br><span class="line">  			    <span class="built_in">Rotate</span>((x-&gt;Fa-&gt;Son[<span class="number">0</span>] == x)^(x-&gt;Fa-&gt;Fa-&gt;Son[<span class="number">0</span>] == x-&gt;Fa) ? x : x-&gt;Fa);</span><br><span class="line">          &#125;                      <span class="comment">// End</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Rotate</span>(x);               <span class="comment">//最后一次旋转</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="access-2"><a class="markdownIt-Anchor" href="#access-2"></a> <code>Access()</code></h3>
<p>这个操作在变量写得合理的情况下, 可以把一开始的边界情况处理到循环里去, 一个循环解决问题. 但是为了逻辑清晰, 这次还是写得麻烦了一些.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Access</span> <span class="params">(Node *x)</span> </span>&#123;     <span class="comment">// Let x be the bottom of the chain where the root at</span></span><br><span class="line">  <span class="built_in">Splay</span>(x), x-&gt;Son[<span class="number">1</span>] = <span class="literal">NULL</span>, <span class="built_in">Update</span>(x);         <span class="comment">// Delete x&#x27;s right son</span></span><br><span class="line">  <span class="function">Node *<span class="title">Father</span><span class="params">(x-&gt;Fa)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (Father) &#123;</span><br><span class="line">    <span class="built_in">Splay</span>(Father), Father-&gt;Son[<span class="number">1</span>] = x; <span class="comment">// Change the right son</span></span><br><span class="line">    x = Father, Father = x-&gt;Fa, <span class="built_in">Update</span>(x);     <span class="comment">// Go up</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="find_root-2"><a class="markdownIt-Anchor" href="#find_root-2"></a> <code>Find_Root()</code></h3>
<p>结构很简单的函数, 有人说找到根节点 (原树) 后, <code>Splay(x)</code>, 维护复杂度, 实验证明, 最后的 <code>Splay(x)</code> 存在与否不影响效率.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">Find_Root</span><span class="params">(Node *x)</span> </span>&#123;  <span class="comment">// Find the root</span></span><br><span class="line">  <span class="built_in">Access</span>(x), <span class="built_in">Splay</span>(x), <span class="built_in">Push_Down</span>(x);</span><br><span class="line">  <span class="keyword">while</span> (x-&gt;Son[<span class="number">0</span>]) &#123;</span><br><span class="line">    x = x-&gt;Son[<span class="number">0</span>], <span class="built_in">Push_Down</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现操作的接口"><a class="markdownIt-Anchor" href="#实现操作的接口"></a> 实现操作的接口</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Wild_Donkey 0</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="title">RD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> intmp = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">char</span> <span class="title">rdch</span><span class="params">(getchar())</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (rdch &lt; <span class="string">&#x27;0&#x27;</span> || rdch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">    rdch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (rdch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; rdch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">    intmp = intmp * <span class="number">10</span> + rdch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    rdch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> intmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> a[<span class="number">10005</span>], n, m, <span class="built_in">Cnt</span>(<span class="number">0</span>), <span class="built_in">Tmp</span>(<span class="number">0</span>), Mx;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flg</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> inch, List[<span class="number">155</span>][<span class="number">75</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  Node *Son[<span class="number">2</span>], *Fa;</span><br><span class="line">  <span class="type">char</span> Tag;</span><br><span class="line">  <span class="type">unsigned</span> Value, Sum;</span><br><span class="line">&#125;N[<span class="number">100005</span>], *Stack[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">RD</span>();</span><br><span class="line">  m = <span class="built_in">RD</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">    N[i].Value = <span class="built_in">RD</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">unsigned</span> A, B, C;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= m; ++i) &#123;</span><br><span class="line">    A = <span class="built_in">RD</span>();</span><br><span class="line">    B = <span class="built_in">RD</span>();</span><br><span class="line">    C = <span class="built_in">RD</span>();</span><br><span class="line">    <span class="keyword">switch</span> (A) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: &#123; <span class="comment">// Query</span></span><br><span class="line">        <span class="built_in">Access</span>(N + B), <span class="built_in">Splay</span>(N + B), N[B].Tag ^= <span class="number">1</span>; <span class="comment">// x 为根 </span></span><br><span class="line">        <span class="built_in">Access</span>(N + C);    <span class="comment">// y 和 x 为同一实链两端</span></span><br><span class="line">        <span class="built_in">Splay</span>(N + C);     <span class="comment">// y 为所在实链的 Splay 的根 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, N[C].Sum);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: &#123; <span class="comment">// Link</span></span><br><span class="line">        <span class="built_in">Access</span>(N + B), <span class="built_in">Splay</span>(N + B), N[B].Tag ^= <span class="number">1</span>;         <span class="comment">// x 为根, 也是所在 Splay 的根</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Find_Root</span>(N + C) != N + B) &#123;<span class="comment">// x, y 不连通, x 在 Fink_Root 时已经是它所在 Splay 的根了, 也是它原树根所在实链顶, 左子树为空 </span></span><br><span class="line">          N[B].Fa = N + C;        <span class="comment">// 父指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: &#123; <span class="comment">// Cut</span></span><br><span class="line">        <span class="built_in">Access</span>(N + B), <span class="built_in">Splay</span>(N + B), N[B].Tag ^= <span class="number">1</span>;                         <span class="comment">// x 为根, 也是所在 Splay 的根</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Find_Root</span>(N + C) == N + B) &#123;           <span class="comment">// x, y 连通 </span></span><br><span class="line">          <span class="keyword">if</span>(N[B].Fa == N + C &amp;&amp; !(N[B].Son[<span class="number">1</span>])) &#123;</span><br><span class="line">            N[B].Fa = N[C].Son[<span class="number">0</span>] = <span class="literal">NULL</span>;         <span class="comment">// 断边</span></span><br><span class="line">            <span class="built_in">Update</span>(N + C);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: &#123; <span class="comment">// Change</span></span><br><span class="line">        <span class="built_in">Splay</span>(N + B);   <span class="comment">// 转到根上 </span></span><br><span class="line">        N[B].Value = C; <span class="comment">// 改权值 </span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Wild_Donkey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h2>
<p>因为贡献复杂度的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 次操作, 所以考虑单次操作复杂度. 因为每个操作都是基于 LCT 的, 所以 LCT 的复杂度决定了单次操作复杂度.</p>
<p>因为一开始的点都是独立的, 所以这时什么操作复杂度都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.</p>
<p>随着连通块的增大, LCT 的单个 Splay 的复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>, 而虚边的个数决定了单次操作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的系数. 由于每次虚边的产生只出现在 Link 操作中, 而一次 Link 最多增加一个虚边, 这种情况只出现在 Link 过程中没有将任何虚边变实的情况下, 复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>. 所以假设有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次这样的 Link 操作, 那么接下来的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">m - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次操作会比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((m - k)logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的总复杂度多出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(klogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的时间. 每次多用的时间是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Access</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">c</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span></span></span></span> 贡献的, 但是每次 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Access</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">c</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span></span></span></span> 多用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的时间, 虚边就会少 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 所以均摊 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2mlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>, 也就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2>
<p>LCT 作为顶级树上数据结构, 在代码结构独特如此的情况下着实难调, 坑也不少, 希望考场上能吸取这几天 Debug 的教训.</p>
<p>由于时间线拉的比较长, 后半部分是在写完前半部分后花了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 天的 Debug 才写的, 所以可能会有错误和前后矛盾, 希望指正.</p>

                        </div>

                        <!-- Post Comments -->
                        
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'Michael'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://wild-donkey.github.io/Datastructure/Link_Cut_Tree/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://wild-donkey.github.io/Datastructure/Link_Cut_Tree/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//Michael.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


                      </div>
                      <!-- Copyright 版权 start -->
                              <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
                </div>
              </body>


              
 	
</html>
